#!/usr/bin/env python3
# This   script   contains  some  necessary  functions  to  compute  the
# diffracted  electric  and  magnetic fields within the Smythe-Kirchhoff
# approximation.
# It was generated by the Mathematica notebook diffint.nb.

import numpy as np
try:
    from numba import jit
except:
    print("Numba not available, defining a dummy jit decorator.")
    def jit(nopython):
        def decorator(func):
            return func 
        return decorator

def electricKernels(z,k):
    '''
    This function returns the necessary kernels for computing the diffracted electric field
    obtained from the Smythe-Kirchhoff diffraction integrals.

    Parameters
    ----------
    z : float
        the propagation distance
    k : float
        2π n/λ

    Returns
    -------
    (kernEx_Ex, kernEx_Ey), (kernEy_Ex, kernEy_Ey), (kernEz_Ex, kernEz_Ey) : tuple
        all elements being 2-tuples of functions of (x,y)
    '''
    @jit(nopython=True)
    def kernEx_Ex(x,y):
        return (np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*z*(1 - 1j*k*np.sqrt(x**2 + y**2 + z**2)))/(2.*np.pi*(x**2 + y**2 + z**2)**1.5)
    
    @jit(nopython=True)
    def kernEx_Ey(x,y):
        return 0
    kernEx_Ey.null = True

    @jit(nopython=True)
    def kernEy_Ex(x,y):
        return 0
    kernEy_Ex.null = True

    @jit(nopython=True)
    def kernEy_Ey(x,y):
        return (np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*z*(1 - 1j*k*np.sqrt(x**2 + y**2 + z**2)))/(2.*np.pi*(x**2 + y**2 + z**2)**1.5)
    
    @jit(nopython=True)
    def kernEz_Ex(x,y):
        return (0.5j*np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*x*(1j + k*np.sqrt(x**2 + y**2 + z**2)))/(np.pi*(x**2 + y**2 + z**2)**1.5)
    
    @jit(nopython=True)
    def kernEz_Ey(x,y):
        return (0.5j*np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*y*(1j + k*np.sqrt(x**2 + y**2 + z**2)))/(np.pi*(x**2 + y**2 + z**2)**1.5)
    
    return (kernEx_Ex, kernEx_Ey), (kernEy_Ex, kernEy_Ey), (kernEz_Ex, kernEz_Ey)

def magneticKernels(z,k):
    '''
    This function returns the necessary kernels for computing the diffracted magnetic field
    obtained from the Smythe-Kirchhoff diffraction integrals.

    Parameters
    ----------
    z : float
        the propagation distance
    k : float
        2π n/λ
    
    Returns
    -------
    (kernHx_Ex, kernHx_Ey), (kernHy_Ex, kernHy_Ey), (kernHz_Ex, kernHz_Ey) : tuple
        all elements being 2-tuples of functions of (x,y)
    '''
    @jit(nopython=True)
    def kernHx_Ex(x,y):
        return -0.5*(np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*x*y*(-3 + 3j*k*np.sqrt(x**2 + y**2 + z**2) + k**2*(x**2 + y**2 + z**2)))/(np.pi*(x**2 + y**2 + z**2)**2.5)
    
    @jit(nopython=True)
    def kernHx_Ey(x,y):
        return -0.5*(np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*((y**2 + z**2)*(-1 + k**2*(y**2 + z**2) + 1j*k*np.sqrt(x**2 + y**2 + z**2)) + x**2*(2 + k**2*(y**2 + z**2) - 2j*k*np.sqrt(x**2 + y**2 + z**2))))/(np.pi*(x**2 + y**2 + z**2)**2.5)
    
    @jit(nopython=True)
    def kernHy_Ex(x,y):
        return (np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*(k**2*x**4 + 2*y**2 - z**2 + k*(k*z**2*(y**2 + z**2) - 1j*(2*y**2 - z**2)*np.sqrt(x**2 + y**2 + z**2)) + x**2*(-1 + 1j*k*np.sqrt(x**2 + y**2 + z**2) + k**2*(y**2 + 2*z**2))))/(2.*np.pi*(x**2 + y**2 + z**2)**2.5)
    
    @jit(nopython=True)
    def kernHy_Ey(x,y):
        return (np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*x*y*(-3 + 3j*k*np.sqrt(x**2 + y**2 + z**2) + k**2*(x**2 + y**2 + z**2)))/(2.*np.pi*(x**2 + y**2 + z**2)**2.5)
    
    @jit(nopython=True)
    def kernHz_Ex(x,y):
        return -0.5*(np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*y*z*(-3 + 3j*k*np.sqrt(x**2 + y**2 + z**2) + k**2*(x**2 + y**2 + z**2)))/(np.pi*(x**2 + y**2 + z**2)**2.5)
    
    @jit(nopython=True)
    def kernHz_Ey(x,y):
        return (np.exp(1j*k*np.sqrt(x**2 + y**2 + z**2))*x*z*(-3 + 3j*k*np.sqrt(x**2 + y**2 + z**2) + k**2*(x**2 + y**2 + z**2)))/(2.*np.pi*(x**2 + y**2 + z**2)**2.5)
    
    return (kernHx_Ex, kernHx_Ey), (kernHy_Ex, kernHy_Ey), (kernHz_Ex, kernHz_Ey)
