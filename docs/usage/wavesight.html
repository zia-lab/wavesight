<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wavesight &mdash; wavesight  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="wavegraphics" href="wavegraphics.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            wavesight
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="across_ml.html">across_ml</a></li>
<li class="toctree-l1"><a class="reference internal" href="convstore.html">convstore</a></li>
<li class="toctree-l1"><a class="reference internal" href="datapipes.html">datapipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffkernels.html">diffkernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="EH4_animate.html">EH4_animate</a></li>
<li class="toctree-l1"><a class="reference internal" href="EH4_plotter.html">EH4_plotter</a></li>
<li class="toctree-l1"><a class="reference internal" href="EH4_to_EH5.html">EH4_to_EH5</a></li>
<li class="toctree-l1"><a class="reference internal" href="EH5_assembly.html">EH5_assembly</a></li>
<li class="toctree-l1"><a class="reference internal" href="fiber_animate.html">fiber_animate</a></li>
<li class="toctree-l1"><a class="reference internal" href="fiber_bridge.html">fiber_bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="fiber_bundle.html">fiber_bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="fiber_platform.html">fiber_platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="fiber_plotter.html">fiber_plotter</a></li>
<li class="toctree-l1"><a class="reference internal" href="fieldgenesis.html">fieldgenesis</a></li>
<li class="toctree-l1"><a class="reference internal" href="fields.html">fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fungenerators.html">fungenerators</a></li>
<li class="toctree-l1"><a class="reference internal" href="hail_david.html">hail_david</a></li>
<li class="toctree-l1"><a class="reference internal" href="housekeeping.html">housekeeping</a></li>
<li class="toctree-l1"><a class="reference internal" href="maxwell.html">Maxwell’s Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="meta_designer.html">meta_designer</a></li>
<li class="toctree-l1"><a class="reference internal" href="metal.html">metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="metaorchestra.html">metaorchestra</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml_plot_in.html">ml_plot_in</a></li>
<li class="toctree-l1"><a class="reference internal" href="phase_factory.html">phase_factory</a></li>
<li class="toctree-l1"><a class="reference internal" href="printech.html">printech</a></li>
<li class="toctree-l1"><a class="reference internal" href="slacking.html">slacking</a></li>
<li class="toctree-l1"><a class="reference internal" href="sniffer.html">sniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="standard_candle.html">standard_candle</a></li>
<li class="toctree-l1"><a class="reference internal" href="templates.html">templates</a></li>
<li class="toctree-l1"><a class="reference internal" href="wavegraphics.html">wavegraphics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">wavesight</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.FFT2D_convolution_integral"><code class="docutils literal notranslate"><span class="pre">FFT2D_convolution_integral()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.angular_farfield_propagator"><code class="docutils literal notranslate"><span class="pre">angular_farfield_propagator()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.approx_time"><code class="docutils literal notranslate"><span class="pre">approx_time()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.boundary_test"><code class="docutils literal notranslate"><span class="pre">boundary_test()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.calculate_numerical_basis"><code class="docutils literal notranslate"><span class="pre">calculate_numerical_basis()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.calculate_size_of_grid"><code class="docutils literal notranslate"><span class="pre">calculate_size_of_grid()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.coordinate_layout"><code class="docutils literal notranslate"><span class="pre">coordinate_layout()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.device_layout"><code class="docutils literal notranslate"><span class="pre">device_layout()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.electric_vectorial_diffraction"><code class="docutils literal notranslate"><span class="pre">electric_vectorial_diffraction()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.equivCurrents"><code class="docutils literal notranslate"><span class="pre">equivCurrents()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.field_dot"><code class="docutils literal notranslate"><span class="pre">field_dot()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.field_sampler"><code class="docutils literal notranslate"><span class="pre">field_sampler()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.fresnel_t_1"><code class="docutils literal notranslate"><span class="pre">fresnel_t_θ1()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.fresnel_t_12"><code class="docutils literal notranslate"><span class="pre">fresnel_t_θ1θ2()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.fresnel_ts_1"><code class="docutils literal notranslate"><span class="pre">fresnel_ts_θ1()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.fresnel_ts_12"><code class="docutils literal notranslate"><span class="pre">fresnel_ts_θ1θ2()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.from_cart_cart_to_cyl_cart"><code class="docutils literal notranslate"><span class="pre">from_cart_cart_to_cyl_cart()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.from_cyl_cart_to_cart_cart"><code class="docutils literal notranslate"><span class="pre">from_cyl_cart_to_cart_cart()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.from_near_to_far_angular"><code class="docutils literal notranslate"><span class="pre">from_near_to_far_angular()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.from_sampled_field_to_sampled_equiv_currents"><code class="docutils literal notranslate"><span class="pre">from_sampled_field_to_sampled_equiv_currents()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.magnetic_vectorial_diffraction"><code class="docutils literal notranslate"><span class="pre">magnetic_vectorial_diffraction()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.multisolver"><code class="docutils literal notranslate"><span class="pre">multisolver()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.poynting_refractor"><code class="docutils literal notranslate"><span class="pre">poynting_refractor()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.scalar_diffraction"><code class="docutils literal notranslate"><span class="pre">scalar_diffraction()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.simpson_quad_1D"><code class="docutils literal notranslate"><span class="pre">simpson_quad_1D()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.simpson_quad_ND"><code class="docutils literal notranslate"><span class="pre">simpson_quad_ND()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavesight.simpson_weights_1D"><code class="docutils literal notranslate"><span class="pre">simpson_weights_1D()</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">wavesight</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">wavesight</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/usage/wavesight.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="wavegraphics.html" class="btn btn-neutral float-left" title="wavegraphics" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-wavesight">
<span id="wavesight"></span><h1>wavesight<a class="headerlink" href="#module-wavesight" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="wavesight.FFT2D_convolution_integral">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">FFT2D_convolution_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Usamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernelFun</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#FFT2D_convolution_integral"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.FFT2D_convolution_integral" title="Link to this definition">¶</a></dt>
<dd><p>FFT2D_convolution_integral  takes  the  sampled values of a function
U(x,y) on a square domain and computes the convolution integral with
the  given kernel. The domain of integration is given by xCoords and
yCoords,   where  it  is  assumed  that  the  elements  of  Usamples
correspond       to       xCorrds,       yCoords      such      that
<span class="math notranslate nohighlight">\(\text{Usamples}[i,j]         =         U(\text{yCoords}[j],
\text{xCoords}[i])\)</span>.</p>
<p>Usamples  is  numeric,  whereas  kernelFun  must  be  provided  as a
bivariate function.</p>
<p>The convolution has the same domain as the sample values for U.</p>
<div class="math notranslate nohighlight">
\[I(x',y')=\iint_\mathcal{A} U(x,y) \mathcal{K}(x-x', y-y') dxdy\]</div>
<p>This   is  done  by  interpreting  the  discretized  integral  as  a
convolution,  so  that the convolution may be performed with help of
the fast Fourier transform.</p>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>xCoords<span class="classifier">np.array</span></dt><dd><p>x-coordinates on the source plane indexed to the given Usamples.</p>
</dd>
<dt>yCoords<span class="classifier">np.array</span></dt><dd><p>y-coordinates on the source plane indexed to the given Usamples.</p>
</dd>
<dt>Usamples<span class="classifier">np.array</span></dt><dd><p>complex  amplitude  of  the  field  in the source plane,
sampled according to the coordinates provided by xCoords
and yCoords. Must be a square array.</p>
</dd>
<dt>kernelFun<span class="classifier">func</span></dt><dd><p>a bivariate function of the cartesian x,y coordinates.</p>
</dd>
</dl>
</section>
<section id="returns">
<h2>Returns<a class="headerlink" href="#returns" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>integral<span class="classifier">np.array</span></dt><dd><p>resultant  convolution  integral. The top left corner of
the  array  corresponds  to the lower left corner of the
observation  plane. The coordinates associated with each
element  in  the  given array correspond to the original
xCoords, yCoords.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.angular_farfield_propagator">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">angular_farfield_propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">λFree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nMedium</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Zf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Zi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">si</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Δf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#angular_farfield_propagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.angular_farfield_propagator" title="Link to this definition">¶</a></dt>
<dd><p>This function approximates the farfield of a field given the nearfield
and the propagation distance.</p>
<p>This is done by using the angular spectrum method. In which the Fourier
transform of the nearfield is understood to describe the coefficients that
approximate the farfield as a superposition of plane waves.</p>
<p>It assumes that the nearfield is given on a square grid perpendicular to
the z-axis. The farfield is also given on a square grid perpendicular to
the z-axis.</p>
<p>The farfield is approximated by the following formula:
Efar = (2π 1j / kFree) * ((Zf-Zi)/Rfsq) * np.exp(1j*kFree*Rf) * S2
with S2 equal to the Fourier transform extrapolated to the position
of the farfield.</p>
<section id="id1">
<h2>Parameters<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>field<span class="classifier">np.array (3, Ni, Ni) or (Ni, Ni) or (1, Ni, Ni)</span></dt><dd><p>An array describing the nearfield of the field to be propagated.</p>
</dd>
<dt>nMedium<span class="classifier">float</span></dt><dd><p>Refractive index of the homogenous medium or propagation.</p>
</dd>
<dt>Zf<span class="classifier">float</span></dt><dd><p>The z-coordinate of the farfield.</p>
</dd>
<dt>Zi<span class="classifier">float</span></dt><dd><p>The z-coordinate of the nearfield.</p>
</dd>
<dt>si<span class="classifier">float</span></dt><dd><p>The size of the nearfield.</p>
</dd>
<dt>sf<span class="classifier">float</span></dt><dd><p>The size of the farfield.</p>
</dd>
<dt>Δf<span class="classifier">float (optional)</span></dt><dd><p>Spatial resolution of the farfield. If None, it is set to Δi.</p>
</dd>
<dt>options<span class="classifier">dict (optional) A dictionary of options:</span></dt><dd><dl class="simple">
<dt>‘return_fourier’<span class="classifier">bool</span></dt><dd><p>If True, the function also returns the Fourier transform of the
nearfield.</p>
</dd>
<dt>‘return_as_dict’<span class="classifier">bool</span></dt><dd><p>If False, the function returns the two arrays in the same order
as the keys in the dictionary.
If True, the function returns a dictionary with the following
keys:
‘Efar’ : np.array (3, Nf, Nf) The farfield of the field.
‘Efourier’ : np.array (3, Ni, Ni) The Fourier transform of the nearfield.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id2">
<h2>Returns<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p>Return depends on the options dictionary, see above.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.approx_time">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">approx_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spatial_resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.06e-06</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#approx_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.approx_time" title="Link to this definition">¶</a></dt>
<dd><p>Given a MEP simulation cell, the resolution, and
the run time of the simulation, this function will return the approximate
time in seconds that the simulation will take to run.</p>
<p>This function does not take into account possible parallelization of the
simulation.</p>
<section id="id3">
<h2>Parameters<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>sim_cell<span class="classifier">meep.Vector3</span></dt><dd><p>The simulation cell.</p>
</dd>
<dt>spatial_resolution<span class="classifier">int</span></dt><dd><p>The spatial resolution of the simulation. How many pixels per unit length.</p>
</dd>
<dt>run_time<span class="classifier">float</span></dt><dd><p>The run time of the simulation in MEEP units.</p>
</dd>
<dt>kappa<span class="classifier">float, optional</span></dt><dd><p>The proportionality constant that relates the run time of the simulation
to the number of pixels in the simulation cell. The default is 3.06e-6.</p>
</dd>
</dl>
</section>
<section id="id4">
<h2>Returns<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>rtime<span class="classifier">float</span></dt><dd><p>The approximate time in seconds that the simulation will take to run.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.boundary_test">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">boundary_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Efuncs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hfuncs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fiber_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modeType</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#boundary_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.boundary_test" title="Link to this definition">¶</a></dt>
<dd><p>This  function  checks  that a given solution for the fields
satisfies  the  boundary  conditions  at  the  core/cladding
interface within tolerance. If the mode is HE the test is on
the relative difference of all field components being within
tolerance. If the mode is TM or TE then the test is that all
the  components  that  should  be zero are exactly zero, and
that  the relative difference for the non-zero components is
within tolerance.</p>
<section id="id5">
<h2>Parameters<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Efuncs<span class="classifier">tuple</span></dt><dd><p>a  tuple  of  six  functions  which  describe  the three
components  of  the  H  field  in  the core and cladding
regions.</p>
</dd>
<dt>Hfuncs<span class="classifier">tuple </span></dt><dd><p>a  tuple  of  six  functions  which  describe  the three
components  of  the  H  field  in  the core and cladding
regions.</p>
</dd>
<dt>fiber_spec<span class="classifier">dict</span></dt><dd><p>a dictionary containing the fiber specifications.</p>
</dd>
<dt>modeType<span class="classifier">str</span></dt><dd><p>must be one of ‘HE’, ‘TE’, or ‘TM’.</p>
</dd>
<dt>tolerance :float</dt><dd><p>the tolerance for the boundary condition test.</p>
</dd>
</dl>
</section>
<section id="id6">
<h2>Returns<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>boundaryTest<span class="classifier">bool</span></dt><dd><p>True if test OK, False otherwise.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.calculate_numerical_basis">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">calculate_numerical_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fiber_sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#calculate_numerical_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.calculate_numerical_basis" title="Link to this definition">¶</a></dt>
<dd><p>Given a solution for the propagation modes of an optical waveguide, calculate a numerical basis.</p>
<section id="id7">
<h2>Parameters<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>fiber_sol<span class="classifier">dict with at least the following keys:</span></dt><dd><dl class="simple">
<dt>‘coreRadius’<span class="classifier">float</span></dt><dd><p>The radius of the core.</p>
</dd>
<dt>‘nCladding’<span class="classifier">float</span></dt><dd><p>The refractive index of the cladding.</p>
</dd>
<dt>‘nCore’<span class="classifier">float</span></dt><dd><p>The refractive index of the core.</p>
</dd>
<dt>‘free_space_wavelength’<span class="classifier">float</span></dt><dd><p>The wavelength of the light in free space.</p>
</dd>
<dt>‘totalModes’<span class="classifier">int</span></dt><dd><p>The total number of calculated modes.</p>
</dd>
<dt>‘TEkz’<span class="classifier">1D dict</span></dt><dd><p>A single key equal to m=0, the values are array with
the TE modes propagation constants.</p>
</dd>
<dt>‘TMkz’<span class="classifier">1D dict</span></dt><dd><p>A single key equal to m=0, the values are array with
the TM modes propagation constants.</p>
</dd>
<dt>‘HEkz’<span class="classifier">1D dict</span></dt><dd><p>Keys are m values, values are 1D arrays of kz values.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id8">
<h2>Returns<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>fiber_sol<span class="classifier">dict the same dictionary as the input, but with two new keys:</span></dt><dd><dl class="simple">
<dt>‘coord_layout’<span class="classifier">tuple</span></dt><dd><p>The tuple returned by the coordinate_layout function.</p>
</dd>
<dt>‘eigenbasis’<span class="classifier">5D np.array</span></dt><dd><p>The numerical basis. The first dimension is the mode number,
the second dimension only has two values, 0 and 1, 0 for the
E  field, and 1 for the H field. The third dimension is used
for  the  different components of the corresponding field in
cylindrical  coordinates.  The  first index being the radial
component,  the  second index being the azimuthal component,
and  the  third  index  being  the  z component. Finally the
fourth  and fifth dimensions are arrays that hold the values
of   the  corresponding  field  components.  The  modes  are
enumerated  such that first all TE modes are given, then all
TM modes, and finally all HE modes. This same enumeration is
the one used for the ‘eigenbasis_nums’ key.</p>
</dd>
<dt>‘eigenbasis_nums’<span class="classifier">list of tuples</span></dt><dd><p>A  list  of tuples, each tuple has 7 values, the first value
is  a  string indicating the type of mode, and can be either
‘TE’, ‘TM’, or ‘HE’. The second value is a string indicating
the  parity  of the mode. The third value is the value of m.
The  fourth  value  corresponds  to  the  value  of  kz, the
propagation  constant along the z-direction. The fifth value
is   the   index  that  the  value  of  kz  has  within  the
corresponding  array  listing the propagation constants. The
sixth  value  is  the transverse propagation constant inside
the  core.  The seventh value is the propagation constant in
the cladding. (modType, parity, m, kzidx, kz, γ, β)</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.calculate_size_of_grid">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">calculate_size_of_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fiber_sol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#calculate_size_of_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.calculate_size_of_grid" title="Link to this definition">¶</a></dt>
<dd><p>Given a solution for the modes of a multimode fiber, determine
the half side of the computational domain that would capture
most of the energy contained in the solved modes.</p>
<section id="id9">
<h2>Parameters<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>fiber_sol<span class="classifier">dict</span></dt><dd><p>a dictionary containing the solution for the fiber.</p>
</dd>
</dl>
</section>
<section id="id10">
<h2>Returns<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>b<span class="classifier">float</span></dt><dd><p>the width of the computational domain.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.coordinate_layout">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">coordinate_layout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fiber_sol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#coordinate_layout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.coordinate_layout" title="Link to this definition">¶</a></dt>
<dd><p>Given a fiber solution, return the coordinate arrays for plotting
and coordinating the numerical analysis.</p>
<section id="id11">
<h2>Parameters<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>fiber_sol<span class="classifier">dict  with at least the following keys:</span></dt><dd><dl class="simple">
<dt>‘coreRadius’<span class="classifier">float</span></dt><dd><p>The radius of the core.</p>
</dd>
<dt>‘claddingIndex’<span class="classifier">float  </span></dt><dd><p>The refractive index of the cladding.</p>
</dd>
<dt>‘coreIndex’<span class="classifier">float</span></dt><dd><p>The refractive index of the core.</p>
</dd>
<dt>‘free_space_wavelength’<span class="classifier">float</span></dt><dd><p>The wavelength of the light in free space.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id12">
<h2>Returns<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>a, b, Δs, xrange, yrange, ρrange, φrange, Xg, Yg, ρg, φg, nxy, crossMask<span class="classifier">tuple</span></dt><dd><dl class="simple">
<dt>a<span class="classifier">float</span></dt><dd><p>The radius of the core.</p>
</dd>
<dt>b<span class="classifier">float</span></dt><dd><p>The side of the computational domain.</p>
</dd>
<dt>Δs<span class="classifier">float</span></dt><dd><p>The sampling resolution in the x-y direction. Assumed to be half the 
wavelength in the core.</p>
</dd>
<dt>xrange, yrange<span class="classifier">1D arrays</span></dt><dd><p>The coordinate arrays for the x-y directions.</p>
</dd>
<dt>ρrange, φrange<span class="classifier">1D arrays</span></dt><dd><p>The coordinate arrays for the ρ-φ directions in the cylindrical system.</p>
</dd>
<dt>Xg, Yg<span class="classifier">2D arrays</span></dt><dd><p>The coordinate arrays for x-y.</p>
</dd>
<dt>ρg, φg<span class="classifier">2D arrays</span></dt><dd><p>ρg has the values for the radial coordinate, φg has the values for the
azimuthal coordinate.</p>
</dd>
<dt>nxy<span class="classifier">2D array</span></dt><dd><p>The refractive index profile of the waveguide.</p>
</dd>
<dt>crossMask<span class="classifier">2D array</span></dt><dd><p>A mask that is True where the core is and False where the cladding is.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.device_layout">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">device_layout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_design</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text_legend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#device_layout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.device_layout" title="Link to this definition">¶</a></dt>
<dd><p>This function creates a figure representing the device layout.</p>
<section id="id13">
<h2>Parameters<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>device_design<span class="classifier">dict with at least the following keys:</span></dt><dd><dl class="simple">
<dt>coreRadius<span class="classifier">float</span></dt><dd><p>the radius of the core in μm</p>
</dd>
<dt>mlRadius<span class="classifier">float</span></dt><dd><p>the radius of the metalens in μm</p>
</dd>
<dt>Δ<span class="classifier">float</span></dt><dd><p>the distance between the end face of the
fiber and the start of the metalens in μm</p>
</dd>
<dt>mlPitch<span class="classifier">float</span></dt><dd><p>the pitch of the metalens in μm</p>
</dd>
<dt>emDepth<span class="classifier">float</span></dt><dd><p>the  depth of the emitter in the
crystal  host  in μm, measured from the base of the
metalens pillars</p>
</dd>
<dt>emΔxy<span class="classifier">float</span></dt><dd><p>the lateral uncertainty (in μm) in
the position of the emitter</p>
</dd>
<dt>emΔz<span class="classifier">float</span></dt><dd><p>the uncertainty in the axial position
of the emitter in μm</p>
</dd>
<dt>mlHeight<span class="classifier">float</span></dt><dd><p>the height of the metalens in μm</p>
</dd>
<dt>λFree<span class="classifier">float</span></dt><dd><p>the  free-space  wavelength of the
emitter in μm</p>
</dd>
<dt>nCore<span class="classifier">float</span></dt><dd><p>the refractive index of the core</p>
</dd>
<dt>nHost<span class="classifier">float</span></dt><dd><p>the refractive index of the host</p>
</dd>
<dt>nClad<span class="classifier">float</span></dt><dd><p>the refractive index of the cladding</p>
</dd>
<dt>NA<span class="classifier">float</span></dt><dd><p>the numerical aperture of the fiber</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id14">
<h2>Returns<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h2>
<p>fig, ax: the figure and axis objects</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.electric_vectorial_diffraction">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">electric_vectorial_diffraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zProp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incidentEfield</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">λfree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#electric_vectorial_diffraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.electric_vectorial_diffraction" title="Link to this definition">¶</a></dt>
<dd><p>Given  samples  of  the  electric  field  of an electromagnetic wave
incident  on  the  aperture  plane z=z0, this function estimates the
electric  field at the observation plane z = z0+zProp.  This is done
using   the  vectorial  Smythe-Kirchhoff  diffraction  integral.  It
assumes  that  both  the  space  below  and above the plane z=z0 are
filled  with  a homogeneous medium with refractive index nref. Since
the  diffraction integral only requires the transverse components of
the  electric field, the input can include or not the z-component of
the field in the source plane.</p>
<p>This  assumes  that  the  field  is incident from below the aperture
plane.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \vec{E}(x,y) &amp;= \frac{1}{2\pi} \nabla \times \iint_\mathcal{A} 
    \frac{e^{i k R}}{R} \left(\hat{z} \times \vec{E}(x',y',z=z_0) \right)
    \,\,\text{dx}\text{dy} \\
    \vec{R} &amp;= \vec{r} - \vec{r}'
\end{align}\end{split}\]</div>
<section id="id15">
<h2>Parameters<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>zProp<span class="classifier">float</span></dt><dd><p>the propagation distance along the z-axis.</p>
</dd>
<dt>incidentEfield<span class="classifier">np.array</span></dt><dd><p>either  (3,N,N)  or (2,N,N), the incident electric field
on  the  aperture  plane. The values given in it so that
the  first  index references the x, y, or z component of
the  incident  field.  Also the values are assumed to be
anchored    to    the    coordinate   system   so   that
incidentEfield[k,i,j]  gives  the  k-th component of the
electric field at position xCoords[j], yCoords[i].</p>
</dd>
<dt>xCoords<span class="classifier">np.array (N,)</span></dt><dd><p>coordinate array for the x-axis.</p>
</dd>
<dt>yCoords<span class="classifier">np.array (N,)</span></dt><dd><p>coordinate array for the x-axis.</p>
</dd>
</dl>
</section>
<section id="id16">
<h2>Returns<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>diffractedEfield<span class="classifier">np.array (3,N,N)</span></dt><dd><p>the  diffracted field at the observation plane.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.equivCurrents">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">equivCurrents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Efuncs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hfuncs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coreRadius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#equivCurrents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.equivCurrents" title="Link to this definition">¶</a></dt>
<dd><p>This  function  returns  the necessary magnetic and electric
currents  corresponding  to  the  given field functions. The
currents  are  calculated  in  a  plane  perpedicular to the
z-axis,  and  are  returned  so  that  they are functions of
cartesian   x,y  coordinates  and  represent  the  different
cartesian components of the currents.</p>
<section id="id17">
<h2>Parameters<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Efuncs<span class="classifier">6-tuple of functions</span></dt><dd><p>Having    the   structure   (ECoreρ,   ECoreϕ,   Ecorez,
ECladdingρ,  ECladdingϕ, Ecladdingz). The z-component is
not needed, if it is included, then it is neglected. The
first  three  functions  describing  the  electric field
inside  of the core and the following three the electric
field in the cladding.</p>
</dd>
<dt>Hfuncs<span class="classifier">6-tuple of functions</span></dt><dd><p>Having    the   structure   (HCoreρ,   HCoreϕ,   HCorez,
HCladdingρ,  HCladdingϕ, HCladdingz). The z-component is
not needed, if it is included, then it is neglected. The
first  three  functions describing the H-field inside of
the  core  and  the  following  three the H-field in the
cladding.</p>
</dd>
<dt>coreRadius<span class="classifier">float</span></dt><dd><p>The radius of the core.</p>
</dd>
<dt>m<span class="classifier">int</span></dt><dd><p>The azimuthal mode number.</p>
</dd>
<dt>parity<span class="classifier">str</span></dt><dd><p>The parity of the mode. Can be ‘TETM’, ‘EVEN’, or ‘ODD’.</p>
</dd>
</dl>
</section>
<section id="id18">
<h2>Returns<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>JKfuns<span class="classifier">tuple of functions</span></dt><dd><p>Provided  as  (Jx, Jy, Kx, Ky). With Jx and Jy being the
functions  for  the  x-y  components  of  the equivalent
electric  current, and Kx and Ky being the functions for
the  x-y  components of the equivalent magnetic current.
Each  of the functions is a function of vec, which needs
to be an iterable with <em>three</em> elements corresponding to
the  x,y,z  cartesian components; this is to account for
the  fact  that  MEEP requires these functions to take a
single Vector3 argument.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.field_dot">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">field_dot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Δs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#field_dot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.field_dot" title="Link to this definition">¶</a></dt>
<dd><p>Be mindful that this includes a factor of 1/2.</p>
<section id="id19">
<h2>Parameters<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>E_field<span class="classifier">np.array</span></dt><dd><p>an electric field sampled on a cartesian grid of size Δs</p>
</dd>
<dt>H_field<span class="classifier">np.array</span></dt><dd><p>a magnetic field sampled on a cartesian grid of size Δs</p>
</dd>
<dt>Δs<span class="classifier">float</span></dt><dd><p>the grid spacing</p>
</dd>
<dt>mask<span class="classifier">np.array</span></dt><dd><p>a mask to apply to the fields (same size as E_field[0,:,:] and H_field[0,:,:])</p>
</dd>
</dl>
</section>
<section id="id20">
<h2>Returns<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>dotp<span class="classifier">float</span></dt><dd><p>the dot product of the two given fields</p>
</dd>
</dl>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Syner and Love, Optical Waveguide Theory, 1983, eqn. 11-10.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.field_sampler">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">field_sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funPairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coreRadius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord_sys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cartesian-cylindrical'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equiv_currents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#field_sampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.field_sampler" title="Link to this definition">¶</a></dt>
<dd><p>Given  the  functions that describe the H and E fields in the core and
cladding, this function can be used to sample either the fields or the
equivalent  currents  on the centered computational grid of given size
and resolution.</p>
<section id="id21">
<h2>Parameters<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>funPairs<span class="classifier">3-tuple of 2-tuples of 2-tuples of functions</span></dt><dd><p>The  functions  that  describe the field in the core and cladding.
Having the following structure:
(
((ECoreρ, ECladdingρ), (HCoreρ, HCladdingρ)),
((ECoreϕ, ECladdingϕ), (HCoreϕ, HCladdingϕ)),
((ECorez, ECladdingz), (HCorez, HCladdingz))
)</p>
</dd>
<dt>cross_width<span class="classifier">float</span></dt><dd><p>The width of the cross-section of the computational grid.</p>
</dd>
<dt>resolution<span class="classifier">float</span></dt><dd><p>How many pixels per unit length.</p>
</dd>
<dt>m<span class="classifier">int</span></dt><dd><p>The azimuthal mode number.</p>
</dd>
<dt>parity<span class="classifier">str</span></dt><dd><p>The parity of the mode. Can be ‘TETM’, ‘EVEN’, or ‘ODD’.</p>
</dd>
<dt>coreRadius<span class="classifier">float</span></dt><dd><p>The radius of the core.</p>
</dd>
<dt>coord_sys<span class="classifier">str, optional</span></dt><dd><p>The coordinate system of the field. Can be ‘cartesian-cylindrical’
or  ‘cartesian-cartesian’. The default is ‘cartesian-cylindrical’.
The  first  word  determines  the coordinate system of the grid in
which the field is being described; the second word determines the
coordinate system of the field itself in those points.</p>
</dd>
<dt>equiv_currents<span class="classifier">bool, optional</span></dt><dd><p>Whether  to  return the equivalent electric and magnetic currents.
The  default  is False. This is assuming that the normal is in the
z-direction. Furthermore, it assumes that the only necessary sheet
of  current  is a single plane, whereas in rigor one would need to
envelop the simulation volume with these currents.</p>
</dd>
</dl>
</section>
<section id="id22">
<h2>Returns<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Xg, Yg, E_field, H_field<span class="classifier">tuple of ndarrays</span></dt><dd><p>Returned if equiv_currents is False. The first two are the meshgrid
of  the  computational  grid.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.fresnel_t_1">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">fresnel_t_θ1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">θ1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#fresnel_t_θ1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.fresnel_t_1" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the electric field transmission
coefficients for S and P polarization.
Use if only one angle is known beforehand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌───────────────────────────────────────────────┐
│                       │                 ┌─    │
│                       │               ┌─┘     │
│                       │             ┌─┘       │
│                       ├──┐        ┌─┘         │
│                       │  └θ2─┐  ┌─┘           │
│                       │      └┬─┘             │
│                       │     ┌─┘               │
│                       │   ┌─┘                 │
│                       │ ┌─┘             n2    │
│ ______________________├─┘____________________ │
│ |||||||||||||||||||||╱│|||||||||||||||||||||| │
│ ||||||||||||||||||||╱|│|||||||||||||||| n1 || │
│ |||||||||||||||||||╱||│|||||||||||||||||||||| │
│ ||||||||||||||||||╱|||│|||||||||||||||||||||| │
│ |||||||||||||||||╱||||│|||||||||||||||||||||| │
│ ||||||||||||||||╱|||||│|||||||||||||||||||||| │
│ |||||||||||||||╱─┐||||│|||||||||||||||||||||| │
│ ||||||||||||||╱||└θ1┐|│|||||||||||||||||||||| │
│ |||||||||||||╱||||||└─┤|||||||||||||||||||||| │
│ ||||||||||||╱|||||||||│|||||||||||||||||||||| │
└───────────────────────────────────────────────┘
</pre></div>
</div>
<section id="id23">
<h2>Parameters<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>n1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 1</p>
</dd>
<dt>n2<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 2</p>
</dd>
<dt>θ1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>angle in medium 1</p>
</dd>
<dt>θ2<span class="classifier">float or np.array((N,M))</span></dt><dd><p>angle in medium 2</p>
</dd>
</dl>
</section>
<section id="id24">
<h2>Returns<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h2>
<p>np.array([ts,tp]) : np.array</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.fresnel_t_12">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">fresnel_t_θ1θ2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">θ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">θ2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#fresnel_t_θ1θ2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.fresnel_t_12" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the electric field transmission
coefficients for S and P polarization.
Use if both angles are known beforehand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌───────────────────────────────────────────────┐
│                       │                 ┌─    │
│                       │               ┌─┘     │
│                       │             ┌─┘       │
│                       ├──┐        ┌─┘         │
│                       │  └θ2─┐  ┌─┘           │
│                       │      └┬─┘             │
│                       │     ┌─┘               │
│                       │   ┌─┘                 │
│                       │ ┌─┘             n2    │
│ ______________________├─┘____________________ │
│ |||||||||||||||||||||╱│|||||||||||||||||||||| │
│ ||||||||||||||||||||╱|│|||||||||||||||| n1 || │
│ |||||||||||||||||||╱||│|||||||||||||||||||||| │
│ ||||||||||||||||||╱|||│|||||||||||||||||||||| │
│ |||||||||||||||||╱||||│|||||||||||||||||||||| │
│ ||||||||||||||||╱|||||│|||||||||||||||||||||| │
│ |||||||||||||||╱─┐||||│|||||||||||||||||||||| │
│ ||||||||||||||╱||└θ1┐|│|||||||||||||||||||||| │
│ |||||||||||||╱||||||└─┤|||||||||||||||||||||| │
│ ||||||||||||╱|||||||||│|||||||||||||||||||||| │
└───────────────────────────────────────────────┘
</pre></div>
</div>
<section id="id25">
<h2>Parameters<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>n1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 1</p>
</dd>
<dt>n2<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 2</p>
</dd>
<dt>θ1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>angle in medium 1</p>
</dd>
<dt>θ2<span class="classifier">float or np.array((N,M))</span></dt><dd><p>angle in medium 2</p>
</dd>
</dl>
</section>
<section id="id26">
<h2>Returns<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h2>
<p>np.array([ts,tp]) : np.array</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.fresnel_ts_1">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">fresnel_ts_θ1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">θ1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#fresnel_ts_θ1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.fresnel_ts_1" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the electric field transmission
and reflection coefficients for S and P polarization.
Use if only one angle is known beforehand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌───────────────────────────────────────────────┐
│                       │                 ┌─    │
│                       │               ┌─┘     │
│                       │             ┌─┘       │
│                       ├──┐        ┌─┘         │
│                       │  └θ2─┐  ┌─┘           │
│                       │      └┬─┘             │
│                       │     ┌─┘               │
│                       │   ┌─┘                 │
│                       │ ┌─┘             n2    │
│ ______________________├─┘____________________ │
│ |||||||||||||||||||||╱│|||||||||||||||||||||| │
│ ||||||||||||||||||||╱|│|||||||||||||||| n1 || │
│ |||||||||||||||||||╱||│|||||||||||||||||||||| │
│ ||||||||||||||||||╱|||│|||||||||||||||||||||| │
│ |||||||||||||||||╱||||│|||||||||||||||||||||| │
│ ||||||||||||||||╱|||||│|||||||||||||||||||||| │
│ |||||||||||||||╱─┐||||│|||||||||||||||||||||| │
│ ||||||||||||||╱||└θ1┐|│|||||||||||||||||||||| │
│ |||||||||||||╱||||||└─┤|||||||||||||||||||||| │
│ ||||||||||||╱|||||||||│|||||||||||||||||||||| │
└───────────────────────────────────────────────┘
</pre></div>
</div>
<section id="id27">
<h2>Parameters<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>n1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 1</p>
</dd>
<dt>n2<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 2</p>
</dd>
<dt>θ1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>angle in medium 1</p>
</dd>
</dl>
</section>
<section id="id28">
<h2>Returns<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h2>
<p>np.array([ts,tp]) : np.array</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.fresnel_ts_12">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">fresnel_ts_θ1θ2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">θ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">θ2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#fresnel_ts_θ1θ2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.fresnel_ts_12" title="Link to this definition">¶</a></dt>
<dd><p>This function returns the electric field transmission
and reflection coefficients for S and P polarization.
Use if both angles are known beforehand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌───────────────────────────────────────────────┐
│                       │                 ┌─    │
│                       │               ┌─┘     │
│                       │             ┌─┘       │
│                       ├──┐        ┌─┘         │
│                       │  └θ2─┐  ┌─┘           │
│                       │      └┬─┘             │
│                       │     ┌─┘               │
│                       │   ┌─┘                 │
│                       │ ┌─┘             n2    │
│ ______________________├─┘____________________ │
│ |||||||||||||||||||||╱│|||||||||||||||||||||| │
│ ||||||||||||||||||||╱|│|||||||||||||||| n1 || │
│ |||||||||||||||||||╱||│|||||||||||||||||||||| │
│ ||||||||||||||||||╱|||│|||||||||||||||||||||| │
│ |||||||||||||||||╱||||│|||||||||||||||||||||| │
│ ||||||||||||||||╱|||||│|||||||||||||||||||||| │
│ |||||||||||||||╱─┐||||│|||||||||||||||||||||| │
│ ||||||||||||||╱||└θ1┐|│|||||||||||||||||||||| │
│ |||||||||||||╱||||||└─┤|||||||||||||||||||||| │
│ ||||||||||||╱|||||||||│|||||||||||||||||||||| │
└───────────────────────────────────────────────┘
</pre></div>
</div>
<section id="id29">
<h2>Parameters<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>n1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 1</p>
</dd>
<dt>n2<span class="classifier">float or np.array((N,M))</span></dt><dd><p>refractive index of medium 2</p>
</dd>
<dt>θ1<span class="classifier">float or np.array((N,M))</span></dt><dd><p>angle in medium 1</p>
</dd>
</dl>
</section>
<section id="id30">
<h2>Returns<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h2>
<p>np.array([ts,tp]) : np.array</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.from_cart_cart_to_cyl_cart">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">from_cart_cart_to_cyl_cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#from_cart_cart_to_cyl_cart"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.from_cart_cart_to_cyl_cart" title="Link to this definition">¶</a></dt>
<dd><p>Given  a  field  in  cartesian  coordinates,  convert  it to
cylindrical  coordinates.  This assumes that the given field
represents   the   vector  field  in  cartesian  coordinates
anchored  in  a  centered  cartesian grid. The function then
returns  a  field that would be sampled in the same centered
cartesian  grid,  but  the field values are now given in the
associated cylindrical coordinate system.</p>
<p>ATTENTION:  This  function assumes that the region described
by  the  cartesian  coordinates  is a square centered on the
axis.</p>
<section id="id31">
<h2>Parameters<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>field<span class="classifier">np.array</span></dt><dd><p>A   field   in  cartesian  coordinates  with  shape  (3,
numSamples,  numSamples) the indices being the x, y, and
z components respectively of the given vector field.</p>
</dd>
</dl>
</section>
<section id="id32">
<h2>Returns<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>cylfield<span class="classifier">np.array</span></dt><dd><p>A  field  in  cylindrical  coordinates  with  shape  (3,
numSamples,  numSamples) the indices being the ρ, φ, and
z components respectively.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.from_cyl_cart_to_cart_cart">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">from_cyl_cart_to_cart_cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#from_cyl_cart_to_cart_cart"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.from_cyl_cart_to_cart_cart" title="Link to this definition">¶</a></dt>
<dd><p>Given  a  field  in  cylindrical  coordinates, convert it to
cartesian  coordinates.  The  given  field  is assumed to be
anchored  to a cartesian coordinate system in the sense that
each  of the indices in its array corresponds to a cartesian
grid  in the usual sense but the value of the vector at that
position is given in terms of cylindrical coordinates.</p>
<p>This  function  assumes  that  the  region  described by the
cartesian coordinates is a square centered on the axis.</p>
<section id="id33">
<h2>Parameters<a class="headerlink" href="#id33" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>field<span class="classifier">np.array</span></dt><dd><p>A  field  in  cylindrical  coordinates  with  shape  (3,
numSamples,  numSamples) the indices being the ρ, φ, and
z components respectively.</p>
</dd>
</dl>
</section>
<section id="id34">
<h2>Returns<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>ccfield<span class="classifier">np.array</span></dt><dd><p>A   field   in  cartesian  coordinates  with  shape  (3,
numSamples,  numSamples) the indices being the x, y, and
z components respectively of the given vector field.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.from_near_to_far_angular">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">from_near_to_far_angular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xy_span</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kMedium</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plotFun=&lt;function</span> <span class="pre">real&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angular_resolution=0.06283185307179587</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">make_plots=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddata_method='nearest'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#from_near_to_far_angular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.from_near_to_far_angular" title="Link to this definition">¶</a></dt>
<dd><section id="id35">
<h2>Parameters<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>field<span class="classifier">np.array (N, N)</span></dt><dd><p>Values, possibly complex, of the given field.</p>
</dd>
<dt>xy_span<span class="classifier">float</span></dt><dd><p>The spatial extent in both the x and y axes that 
corresponds to the given field array.</p>
</dd>
<dt>kMedium<span class="classifier">float</span></dt><dd><p>The magnitude of the homogeneous-medium wavevector</p>
</dd>
<dt>plotFun<span class="classifier">func</span></dt><dd><p>In case plots are presented, this function is 
applied to the given array before plotting.</p>
</dd>
<dt>angular_resolution: float, optional</dt><dd><p>To what angular resolution the angular representation
of the field is calculated.</p>
</dd>
<dt>make_plots: bool</dt><dd><p>Whether to show plots as the calculation is carried out.</p>
</dd>
</dl>
</section>
<section id="id36">
<h2>Returns<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>(angular_rep, theta_range, phi_range, phi_sum, θmax)<span class="classifier">tuple</span></dt><dd><dl class="simple">
<dt>angular_rep<span class="classifier">np.array (M, M)</span></dt><dd><p>The field values in angular coordinates (θ, ϕ).</p>
</dd>
<dt>theta_range<span class="classifier">np.array</span></dt><dd><p>With the values of θ that match the provided angular_rep.</p>
</dd>
<dt>phi_range<span class="classifier">np.array</span></dt><dd><p>With the values of ϕ that match the provided angular_rep.</p>
</dd>
<dt>phi_sum<span class="classifier">np.array</span></dt><dd><p>angular_rep summed along the ϕ axis</p>
</dd>
<dt>θmax<span class="classifier">float</span></dt><dd><p>The angle, in degrees, at which phi_sum is max.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.from_sampled_field_to_sampled_equiv_currents">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">from_sampled_field_to_sampled_equiv_currents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">EH_field</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#from_sampled_field_to_sampled_equiv_currents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.from_sampled_field_to_sampled_equiv_currents" title="Link to this definition">¶</a></dt>
<dd><p>Given  cartesian  samples  of  the  E-H field, this function
returns the cartesian samples of the equivalent electric and
magnetic currents.</p>
<p>This function assumes that the samples are in a z-plane, and
that the field is solely propagating in the +z direction. In
this case the currents  have  no  z-component  so  that  the 
arrays this function returns are of shape (2, N, N).</p>
<p>Note that rigurously the equivalent currents are defined for
a  surface  of  zero  thickness  and  infinite  extent.  The
function  assumes  that  the  given  field  is  defined  for
a  finite  region  of  space  and  that  the  equivalent  is
therefore  defined  for  a  finite  region  of  space.  This
function  assumes  that  the  region  of  space  is  a square
centered on the axis.</p>
<p>This function is agnostic to the actual coordinates in which
the field has been sampled. The returned currents are to  be
assumed to be sampled in the same region.</p>
<section id="id37">
<h2>Parameters<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>EH_field<span class="classifier">np.ndarray</span></dt><dd><p>Sampled EH field,  in  cartesian  coordinates, of  shape
(2, 3, N, N) or (2, 2, N, N).</p>
</dd>
</dl>
</section>
<section id="id38">
<h2>Returns<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>electric_J<span class="classifier">np.ndarray</span></dt><dd><p>Sampled   equivalent   electric   current,  in  cartesian
coordinates, of shape (2, N, N).</p>
</dd>
<dt>magnetic_K<span class="classifier">np.ndarray</span></dt><dd><p>Sampled  equivalent  magnetic   current,   in   cartesian
coordinates, of shape (2, N, N).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.magnetic_vectorial_diffraction">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">magnetic_vectorial_diffraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zProp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incidentEfield</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">λfree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#magnetic_vectorial_diffraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.magnetic_vectorial_diffraction" title="Link to this definition">¶</a></dt>
<dd><p>Given  samples  of  the  electric  field  of an electromagnetic wave
incident  on  the  aperture  plane z=z0, this function estimates the
magnecic H-field at the observation plane z = z0+zProp. This is done
using   the  vectorial  Smythe-Kirchhoff  diffraction  integral.  It
assumes  that  both  the  space  below  and above the plane z=z0 are
filled  with  a homogeneous medium with refractive index nref. Since
the  diffraction integral only requires the transverse components of
the  electric field, the input can include or not the z-component of
the field in the source plane.</p>
<p>This  assumes  that  the  field  is incident from below the aperture
plane.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\vec{H}(x,y) &amp;= \frac{1}{2\pi i \omega} \nabla \left(\nabla \times \iint_\mathcal{A} 
\frac{e^{i k R}}{R} \left(\hat{z} \times \vec{E}(x',y',z=z_0) \right)
\,\,\text{dx}\text{dy} \right) \\
\vec{R} &amp;= \vec{r} - \vec{r}'
\end{align}\end{split}\]</div>
<section id="id39">
<h2>Parameters<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>zProp<span class="classifier">float</span></dt><dd><p>the propagation distance along the z-axis.</p>
</dd>
<dt>incidentEfield<span class="classifier">np.array</span></dt><dd><p>either  (3,N,N)  or (2,N,N), the incident electric field
on  the  aperture  plane. The values given in it so that
the  first  index references the x, y, or z component of
the  incident  field.  Also the values are assumed to be
anchored    to    the    coordinate   system   so   that
incidentEfield[k,i,j]  gives  the  k-th component of the
electric field at position xCoords[j], yCoords[i].</p>
</dd>
<dt>xCoords<span class="classifier">np.array</span></dt><dd><p>(N,) coordinate array for the x-axis.</p>
</dd>
<dt>yCoords<span class="classifier">np.array (N,)</span></dt><dd><p>coordinate array for the x-axis.</p>
</dd>
</dl>
</section>
<section id="id40">
<h2>Returns<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>diffractedHfield<span class="classifier">np.array (3,N,N)</span></dt><dd><p>the  diffracted field at the observation plane.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.multisolver">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">multisolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fiber_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solve_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drawPlots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm_te_funcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#multisolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.multisolver" title="Link to this definition">¶</a></dt>
<dd><p>This function solves the propagation constants of a step-index fiber with the given specifications. This assuming that the cladding is so big that it is effectively infinite.</p>
<p>The propagation constants determine the z-dependence of the fields along the z-direction. The propagation constants are always bounded by what would be the plane wave wavenumbers in the cladding or in the core.</p>
<section id="id41">
<h2>Parameters<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>fiber_spec<span class="classifier">dict with the following keys:</span></dt><dd><dl class="simple">
<dt>nCore<span class="classifier">float</span></dt><dd><p>The refractive index of the core.</p>
</dd>
<dt>nCladding<span class="classifier">float</span></dt><dd><p>The refractive index of the cladding. If NA is given then
nCladding is computed to be consistent with the given nCore
and given NA.</p>
</dd>
<dt>coreRadius<span class="classifier">float</span></dt><dd><p>The radius of the core in μm.</p>
</dd>
<dt>λFree<span class="classifier">float</span></dt><dd><p>The wavelength of the light in free space in μm.</p>
</dd>
<dt>grid_divider: int, not necessary here but when later</dt><dd><p>used in the layout generator, this is used to determine
the fineness of the grid by making it equal to
λfree / max(nCore, nCladding, nBetween) / grid_divider</p>
</dd>
</dl>
</dd>
<dt>solve_modes: str</dt><dd><p>either ‘all’ or ‘transvserse’</p>
</dd>
<dt>drawPlots<span class="classifier">bool, optional</span></dt><dd><p>Whether to draw plots of the mode profiles. The default is False.</p>
</dd>
<dt>verbose<span class="classifier">bool, optional</span></dt><dd><p>Whether to print out extra information. The default is False.</p>
</dd>
<dt>tm_te_funcs<span class="classifier">bool, optional</span></dt><dd><p>If True then the return dictionary includes the keys tmfun and tefun. The default is False.</p>
</dd>
</dl>
</section>
<section id="id42">
<h2>Returns<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>sol<span class="classifier">dict with all the keys included in fiber_spec plus these others:</span></dt><dd><dl class="simple">
<dt>kzmax<span class="classifier">float</span></dt><dd><p>2π/λfree * nCladding (no kz larger than this)</p>
</dd>
<dt>kzmin<span class="classifier">float</span></dt><dd><p>2π/λfree * nCore (no kz smaller than this)</p>
</dd>
<dt>Vnum<span class="classifier">float</span></dt><dd><p>The V number of the fiber.</p>
</dd>
<dt>numModesFromVnum: float</dt><dd><p>The number of modes according to the V number.</p>
</dd>
<dt>totalNumModesTE<span class="classifier">int</span></dt><dd><p>The total number of TE modes that were found.</p>
</dd>
<dt>totalNumModesTM<span class="classifier">int</span></dt><dd><p>The total number of TM modes that were found.</p>
</dd>
<dt>totalNumModesHE<span class="classifier">int</span></dt><dd><p>The total number of HE modes that were found, excluding parity.</p>
</dd>
<dt>totalNumModes<span class="classifier">int</span></dt><dd><p>The total number of modes that were found, including parity.</p>
</dd>
<dt>tmfun<span class="classifier">function</span></dt><dd><p>The eigenvalue function for the TM modes.</p>
</dd>
<dt>tefun<span class="classifier">function</span></dt><dd><p>The eigenvalue function for the TE modes.</p>
</dd>
<dt>hefuns<span class="classifier">dict</span></dt><dd><p>The eigenvalue functions for the HE modes. The keys are values of m (m ≥ 1).</p>
</dd>
<dt>TMkz<span class="classifier">array</span></dt><dd><p>The propagation constants of the TM(0,n) modes.</p>
</dd>
<dt>TEkz<span class="classifier">array</span></dt><dd><p>The propagation constants of the TE(0,n) modes.</p>
</dd>
<dt>HEkz<span class="classifier">dict</span></dt><dd><p>The propagation constants of the HE(m,n) modes. The keys are values of m (m ≥ 1). The values are arrays with the kz(m,n) propagation constants.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.poynting_refractor">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">poynting_refractor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Efield</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hfield</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nxy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nBetween</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#poynting_refractor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.poynting_refractor" title="Link to this definition">¶</a></dt>
<dd><p>Approximate  the  refracted  field across a planar interface
using  the Poynting vector as an analog to the wavevector of
a plane-wave.</p>
<p>Any  evanescent  fields  are  ignored. All cases where there
would  be  total  internal reflection the refracted field is
set to zero.</p>
<section id="id43">
<h2>Parameters<a class="headerlink" href="#id43" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Efield<span class="classifier">np.array (3, N, M)</span></dt><dd><p>The electric field incident on the interface.</p>
</dd>
<dt>Hfield<span class="classifier">np.array (3, N, M)</span></dt><dd><p>The H-field incident on the interface.</p>
</dd>
<dt>nxy<span class="classifier">np.array    (N, M)</span></dt><dd><p>The refractive index transverse to the interface inside the incident medium.</p>
</dd>
<dt>nBetween<span class="classifier">float</span></dt><dd><p>The refractive index of the homogeneous refractive medium.</p>
</dd>
<dt>verbose<span class="classifier">bool, optional</span></dt><dd><p>Whether to print or not progress messages, by default False.</p>
</dd>
</dl>
</section>
<section id="id44">
<h2>Returns<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Eref, Href<span class="classifier">tuple of np.array (3, N, M)</span></dt><dd><p>The refracted electric and magnetic fields.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.scalar_diffraction">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">scalar_diffraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zProp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incidentField</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yCoords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">λfree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#scalar_diffraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.scalar_diffraction" title="Link to this definition">¶</a></dt>
<dd><p>Given  samples  of  the  electric  field  of an electromagnetic wave
incident  on  the  aperture  plane z=z0, this function estimates the
electric  field  at the observation plane z = z0+zProp. This is done
using  the  Rayleigh-Sommerfeld  diffraction integral. This assuming
that  that  both the space below and above the plane z=z0 are filled
with  a  homogeneous  medium  with  refractive index nref.</p>
<div class="math notranslate nohighlight">
\[E(x',y') = \frac{1}{2\pi} \iint_\mathcal{A} \frac{e^{ikR}}{R} \frac{z}{R} \frac{(ikR-1)}{R} E(x',y') \text{dxdy}\]</div>
<p>This  assumes  that  the  field  is incident from below the aperture
plane.</p>
<section id="id45">
<h2>Parameters<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>zProp<span class="classifier">float</span></dt><dd><p>the propagation distance along the z-axis.</p>
</dd>
<dt>incidentEfield<span class="classifier">np.array (N,N)</span></dt><dd><p>the incident field on the aperture plane. The values are
assumed  to be anchored to the coordinate system so that
incidentEfield[i,j]  gives  the  value  of  the field at
position xCoords[j], yCoords[i].</p>
</dd>
</dl>
<ul class="simple">
<li><dl class="simple">
<dt>xCoords<span class="classifier">np.array (N,)</span></dt><dd><p>coordinate array for the x-axis.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>yCoords<span class="classifier">np.array  (N,)</span></dt><dd><p>coordinate array for the x-axis.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="id46">
<h2>Returns<a class="headerlink" href="#id46" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>diffractedEfield<span class="classifier">np.array</span></dt><dd><p>(N,N)  the  diffracted field at the observation plane.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.simpson_quad_1D">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">simpson_quad_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#simpson_quad_1D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.simpson_quad_1D" title="Link to this definition">¶</a></dt>
<dd><p>Given  a 1D array of uniformly sampled values of a function
function  over  a  Cartesian grid, this function returns the
integral over the 0-th index of the array assuming that in
that direction the array contains samples at an interval dx.</p>
<section id="id47">
<h2>Parameters<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>arr: np.array (N, N)</dt><dd><p>Uniform samples of a function on a cartesian grid.</p>
</dd>
<dt>dx: float</dt><dd><p>The size of the sampling, shared by both axes.</p>
</dd>
</dl>
</section>
<section id="id48">
<h2>Returns<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>simp_int: float</dt><dd><p>∑ arr[i,j] B[i] B[j] dx dy</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.simpson_quad_ND">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">simpson_quad_ND</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#simpson_quad_ND"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.simpson_quad_ND" title="Link to this definition">¶</a></dt>
<dd><p>This function takes a multidimensional array with samples of
a multivariate function of cartesian coordinates and returns
the integral over all of the dimensions.</p>
<section id="id49">
<h2>Parameters<a class="headerlink" href="#id49" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>arr: np.array (N, M, …)</dt><dd><p>The samples of the function to be integrated.</p>
</dd>
<dt>dr: iterable or float</dt><dd><p>dr[i] being the sampling interval for dim-i in
the given arr. If a float is given, then the assumption
is that the sampling is equal in every dimension.</p>
</dd>
</dl>
</section>
<section id="id50">
<h2>Returns<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>the_integral<span class="classifier">float</span></dt><dd><p>The required integral.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wavesight.simpson_weights_1D">
<span class="sig-prename descclassname"><span class="pre">wavesight.</span></span><span class="sig-name descname"><span class="pre">simpson_weights_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numSamples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wavesight.html#simpson_weights_1D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#wavesight.simpson_weights_1D" title="Link to this definition">¶</a></dt>
<dd><p>simpson_weights_1D  returns  the  weights  for Simpson’s rule for 1D
numerical integration. Ff there’s an even number of intervals (which
is  the  same  as  an odd number of samples) the 1/3 Simpson rule is
used. If there’s an odd number of intervals (which is the same as an
even number of samples) then Simpson’s 1/3 is used for the first n-3
points and the 3/8 rule is used for the remaining tail.</p>
<section id="id51">
<h2>Parameters<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>numSamples<span class="classifier">int</span></dt><dd><p>how many evaluation points are avaiable for integration</p>
</dd>
</dl>
</section>
<section id="id52">
<h2>Returns<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>BSimpson<span class="classifier">np.array</span></dt><dd><p>array of weights for the mixed Simpson’s rule.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>