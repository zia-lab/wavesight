<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wavesight &mdash; wavesight  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            wavesight
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../usage/wavesight.html">wavesight.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/fields.html">fields.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/maxwell.html">Maxwell’s Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/diffkernels.html">diffkernels.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/misc.html">misc.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/fieldgenesis.html">fieldgenesis.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/fungenerators.html">fungenerators.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/convstore.html">convstore.py</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">wavesight</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">wavesight</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wavesight</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span> 
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root_scalar</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">convstore</span> <span class="kn">import</span> <span class="o">*</span> 
<span class="kn">from</span> <span class="nn">fungenerators</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fieldgenesis</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fields</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">misc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">RegularGridInterpolator</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">fft2</span><span class="p">,</span> <span class="n">ifft2</span>
<span class="kn">import</span> <span class="nn">cmasher</span> <span class="k">as</span> <span class="nn">cmr</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">import</span> <span class="nn">diffkernels</span> <span class="k">as</span> <span class="nn">dk</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="n">real_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="n">complex_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>  

<div class="viewcode-block" id="multisolver">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.multisolver">[docs]</a>
<span class="k">def</span> <span class="nf">multisolver</span><span class="p">(</span><span class="n">fiber_spec</span><span class="p">,</span> <span class="n">solve_modes</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">drawPlots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tm_te_funcs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function solves the propagation constants of a step-index fiber with the given specifications. This assuming that the cladding is so big that it is effectively infinite.</span>

<span class="sd">    The propagation constants determine the z-dependence of the fields along the z-direction. The propagation constants are always bounded by what would be the plane wave wavenumbers in the cladding or in the core.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fiber_spec : dict with the following keys:</span>
<span class="sd">        nCore : float</span>
<span class="sd">            The refractive index of the core.</span>
<span class="sd">        nCladding : float</span>
<span class="sd">            The refractive index of the cladding. If NA is given then</span>
<span class="sd">            nCladding is computed to be consistent with the given nCore</span>
<span class="sd">            and given NA.</span>
<span class="sd">        coreRadius : float</span>
<span class="sd">            The radius of the core in μm.</span>
<span class="sd">        λFree : float</span>
<span class="sd">            The wavelength of the light in free space in μm.</span>
<span class="sd">        grid_divider: int, not necessary here but when later</span>
<span class="sd">            used in the layout generator, this is used to determine</span>
<span class="sd">            the fineness of the grid by making it equal to</span>
<span class="sd">            λfree / max(nCore, nCladding, nFree) / grid_divider</span>
<span class="sd">    solve_modes: str</span>
<span class="sd">        either &#39;all&#39; or &#39;transvserse&#39;</span>
<span class="sd">    drawPlots : bool, optional</span>
<span class="sd">        Whether to draw plots of the mode profiles. The default is False.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Whether to print out extra information. The default is False.</span>
<span class="sd">    tm_te_funcs : bool, optional</span>
<span class="sd">        If True then the return dictionary includes the keys tmfun and tefun. The default is False.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sol : dict with all the keys included in fiber_spec plus these others:</span>
<span class="sd">        kzmax : float</span>
<span class="sd">            2π/λfree * nCladding (no kz larger than this)</span>
<span class="sd">        kzmin : float</span>
<span class="sd">            2π/λfree * nCore (no kz smaller than this)</span>
<span class="sd">        Vnum : float</span>
<span class="sd">            The V number of the fiber.</span>
<span class="sd">        numModesFromVnum: float</span>
<span class="sd">            The number of modes according to the V number.</span>
<span class="sd">        totalNumModesTE : int</span>
<span class="sd">            The total number of TE modes that were found.</span>
<span class="sd">        totalNumModesTM : int</span>
<span class="sd">            The total number of TM modes that were found.</span>
<span class="sd">        totalNumModesHE : int</span>
<span class="sd">            The total number of HE modes that were found, excluding parity.</span>
<span class="sd">        totalNumModes : int</span>
<span class="sd">            The total number of modes that were found, including parity.</span>
<span class="sd">        tmfun : function</span>
<span class="sd">            The eigenvalue function for the TM modes.</span>
<span class="sd">        tefun : function</span>
<span class="sd">            The eigenvalue function for the TE modes.</span>
<span class="sd">        hefuns : dict</span>
<span class="sd">            The eigenvalue functions for the HE modes. The keys are values of m (m ≥ 1).</span>
<span class="sd">        TMkz : array</span>
<span class="sd">            The propagation constants of the TM(0,n) modes.</span>
<span class="sd">        TEkz : array</span>
<span class="sd">            The propagation constants of the TE(0,n) modes.</span>
<span class="sd">        HEkz : dict</span>
<span class="sd">            The propagation constants of the HE(m,n) modes. The keys are values of m (m ≥ 1). The values are arrays with the kz(m,n) propagation constants.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">solve_modes</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;transverse&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">],</span> <span class="s2">&quot;solve_modes must be either all or transverse.&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;invalid value encountered in sqrt&#39;</span><span class="p">)</span>
    <span class="n">nCore</span> <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;nCore&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;NA&#39;</span> <span class="ow">in</span> <span class="n">fiber_spec</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estimating nCladding from nCore and NA ...&quot;</span><span class="p">)</span>
        <span class="n">NA</span>        <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;NA&#39;</span><span class="p">]</span>
        <span class="n">nCladding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nCore</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">NA</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nCladding</span> <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span>
        <span class="n">NA</span>        <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nCore</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">nCladding</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">separator</span>     <span class="o">=</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">40</span>
    <span class="n">coreRadius</span>    <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;coreRadius&#39;</span><span class="p">]</span>
    <span class="n">wavelength</span>    <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;λFree&#39;</span><span class="p">]</span>
    <span class="n">kFree</span>         <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength</span>
    <span class="n">kzmax</span>         <span class="o">=</span> <span class="n">nCore</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength</span>
    <span class="n">kzmin</span>         <span class="o">=</span> <span class="n">nCladding</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength</span>
    <span class="n">kzspan</span>        <span class="o">=</span> <span class="n">kzmax</span> <span class="o">-</span> <span class="n">kzmin</span>
    <span class="n">kzmax</span>         <span class="o">=</span> <span class="n">kzmax</span> <span class="o">-</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">kzspan</span>
    <span class="n">kzmin</span>         <span class="o">=</span> <span class="n">kzmin</span> <span class="o">+</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">kzspan</span>
    <span class="c1"># split the solution domain in at least 300 parts</span>
    <span class="n">dkz</span>           <span class="o">=</span> <span class="p">(</span><span class="n">kzmax</span> <span class="o">-</span> <span class="n">kzmin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="n">sol</span>           <span class="o">=</span> <span class="n">fiber_spec</span>
    <span class="n">Vnum</span>          <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">coreRadius</span> <span class="o">*</span> <span class="n">NA</span> <span class="o">/</span> <span class="n">wavelength</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;Vnum&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">Vnum</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;kFree&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">kFree</span>
    <span class="n">numModes</span>      <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Vnum</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">numModesTE</span>    <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Vnum</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">numModesTM</span>    <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Vnum</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">numModesHE</span>    <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Vnum</span><span class="o">*</span><span class="p">(</span><span class="n">Vnum</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;numModesFromVnum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numModes</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nCladding</span>
    <span class="n">maxHEmodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numModesHE</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Approx number of complex HE modes: &quot;</span><span class="p">,</span> <span class="n">numModesHE</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Approx number of TE modes: &quot;</span><span class="p">,</span> <span class="n">numModesTE</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Approx number of TM modes: &quot;</span><span class="p">,</span> <span class="n">numModesTM</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Approx number of total modes: &quot;</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Approx Max n for HE modes: &quot;</span><span class="p">,</span> <span class="n">maxHEmodes</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
    
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;kzmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzmax</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;kzmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzmin</span>

    <span class="c1"># secular equation for TM modes</span>
    <span class="n">tmfun</span> <span class="o">=</span> <span class="n">tmfungen</span><span class="p">(</span><span class="n">λfree</span> <span class="o">=</span> <span class="n">wavelength</span><span class="p">,</span> 
                        <span class="n">n2</span> <span class="o">=</span> <span class="n">nCladding</span><span class="p">,</span> 
                        <span class="n">n1</span> <span class="o">=</span> <span class="n">nCore</span><span class="p">,</span> 
                         <span class="n">a</span> <span class="o">=</span> <span class="n">coreRadius</span><span class="p">)</span>

    <span class="c1"># secular equation function for TE modes</span>
    <span class="n">tefun</span> <span class="o">=</span> <span class="n">tefungen</span><span class="p">(</span><span class="n">λfree</span> <span class="o">=</span> <span class="n">wavelength</span><span class="p">,</span>  
                        <span class="n">n2</span> <span class="o">=</span> <span class="n">nCladding</span><span class="p">,</span> 
                        <span class="n">n1</span> <span class="o">=</span> <span class="n">nCore</span><span class="p">,</span> 
                         <span class="n">a</span> <span class="o">=</span> <span class="n">coreRadius</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">tm_te_funcs</span><span class="p">:</span>
        <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;tmfun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmfun</span>
        <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;tefun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tefun</span>

    <span class="k">if</span> <span class="n">solve_modes</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;transverse&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
        <span class="n">dkzprime</span> <span class="o">=</span> <span class="n">dkz</span><span class="o">/</span><span class="n">numModesTE</span><span class="o">/</span><span class="mf">2.</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating TM(0,n) propagation constants ...&quot;</span><span class="p">)</span>
        <span class="n">tmmodes</span> <span class="o">=</span> <span class="n">findallroots</span><span class="p">(</span><span class="n">tmfun</span><span class="p">,</span> <span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">,</span> <span class="n">dkzprime</span><span class="p">,</span> 
                            <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">num_sigfigs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating TE(0,n) propagation constants ...&quot;</span><span class="p">)</span>
        <span class="n">temodes</span> <span class="o">=</span> <span class="n">findallroots</span><span class="p">(</span><span class="n">tefun</span><span class="p">,</span> <span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">,</span> <span class="n">dkzprime</span><span class="p">,</span> 
                            <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">num_sigfigs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">kzrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">drawPlots</span><span class="p">:</span>
        <span class="n">tmvals</span> <span class="o">=</span> <span class="n">tmfun</span><span class="p">(</span><span class="n">kzrange</span><span class="p">)</span>
        <span class="n">tevals</span> <span class="o">=</span> <span class="n">tefun</span><span class="p">(</span><span class="n">kzrange</span><span class="p">)</span>
        <span class="n">tmzerocheck</span> <span class="o">=</span> <span class="n">tmfun</span><span class="p">(</span><span class="n">tmmodes</span><span class="p">)</span>
        <span class="n">tezerocheck</span> <span class="o">=</span> <span class="n">tefun</span><span class="p">(</span><span class="n">temodes</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kzrange</span><span class="p">,</span> <span class="n">tmvals</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">tmmodes</span><span class="p">,</span><span class="n">tmzerocheck</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;w:&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;TM modes (</span><span class="si">%d</span><span class="s1"> found)&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmmodes</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kzrange</span><span class="p">,</span> <span class="n">tevals</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">temodes</span><span class="p">,</span><span class="n">tezerocheck</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;w:&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;TE modes (</span><span class="si">%d</span><span class="s1"> found)&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">temodes</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">hemodes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">solve_modes</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating HE(m,n) propagation constants ...&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">approxModes</span> <span class="o">=</span> <span class="n">maxHEmodes</span> <span class="o">-</span> <span class="n">m</span>
            <span class="n">approxModes</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">approxModes</span><span class="p">)</span>
            <span class="n">dkzprime</span> <span class="o">=</span> <span class="n">dkz</span> <span class="o">/</span> <span class="n">approxModes</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;m=</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">hefun</span> <span class="o">=</span> <span class="n">hefungen</span><span class="p">(</span><span class="n">λfree</span><span class="o">=</span><span class="n">wavelength</span><span class="p">,</span> 
                        <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> 
                        <span class="n">n2</span><span class="o">=</span><span class="n">nCladding</span><span class="p">,</span> 
                        <span class="n">n1</span><span class="o">=</span><span class="n">nCore</span><span class="p">,</span> 
                        <span class="n">a</span><span class="o">=</span><span class="n">coreRadius</span><span class="p">)</span>
            <span class="c1"># sol[&#39;hefuns&#39;][m] = hefun</span>
            <span class="n">hevals</span> <span class="o">=</span> <span class="n">hefun</span><span class="p">(</span><span class="n">kzrange</span><span class="p">)</span>
            <span class="n">hezeros</span> <span class="o">=</span> <span class="n">findallroots</span><span class="p">(</span><span class="n">hefun</span><span class="p">,</span> <span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">,</span> <span class="n">dkzprime</span><span class="p">,</span> 
                                <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">,</span> <span class="n">num_sigfigs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hezeros</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">hemodes</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">hezeros</span>
            <span class="n">hezerocheck</span> <span class="o">=</span> <span class="n">hefun</span><span class="p">(</span><span class="n">hezeros</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">drawPlots</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kzrange</span><span class="p">,</span> <span class="n">hevals</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">kzmin</span><span class="p">,</span> <span class="n">kzmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;w:&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hezeros</span><span class="p">,</span> <span class="n">hezerocheck</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.04</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;HE(</span><span class="si">%d</span><span class="s1">, n) roots (</span><span class="si">%d</span><span class="s1"> found)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hezeros</span><span class="p">)))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>  

    <span class="n">numCalcModes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">hemodes</span><span class="o">.</span><span class="n">values</span><span class="p">()))),</span> <span class="nb">len</span><span class="p">(</span><span class="n">temodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmmodes</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HE modes = </span><span class="si">%s</span><span class="se">\n</span><span class="s2">TE modes = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">TM modes = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">TOTAL modes = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">FROM_Vnum = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="o">*</span><span class="n">numCalcModes</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numCalcModes</span><span class="p">),</span> <span class="n">numModes</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
    <span class="c1"># put the modes in the solution dictionary</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;TEkz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">temodes</span><span class="p">}</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;TMkz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">tmmodes</span><span class="p">}</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;HEkz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hemodes</span>
    <span class="n">totalModesTE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="s1">&#39;TEkz&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">totalModesTM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="s1">&#39;TMkz&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">totalModesHE</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;HEkz&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;totalModesTE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalModesTE</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;totalModesTM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalModesTM</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;totalModesHE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalModesHE</span>
    <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;totalModes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalModesTE</span> <span class="o">+</span> <span class="n">totalModesTM</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">totalModesHE</span>
    <span class="k">return</span> <span class="n">sol</span></div>


<div class="viewcode-block" id="field_dot">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.field_dot">[docs]</a>
<span class="k">def</span> <span class="nf">field_dot</span><span class="p">(</span><span class="n">E_field</span><span class="p">,</span> <span class="n">H_field</span><span class="p">,</span> <span class="n">Δs</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    E_field : np.array</span>
<span class="sd">        an electric field sampled on a cartesian grid of size Δs</span>

<span class="sd">    H_field : np.array</span>
<span class="sd">        a magnetic field sampled on a cartesian grid of size Δs</span>

<span class="sd">    Δs : float</span>
<span class="sd">        the grid spacing</span>

<span class="sd">    mask : np.array</span>
<span class="sd">        a mask to apply to the fields (same size as E_field[0,:,:] and H_field[0,:,:])</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dotp : float</span>
<span class="sd">        the dot product of the two given fields</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">E_field</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">E_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">H_field</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">H_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sumField</span> <span class="o">=</span> <span class="n">E_field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">H_field</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">E_field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">H_field</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dotp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sumField</span><span class="p">)</span>
    <span class="n">dotp</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dotp</span> <span class="o">*</span> <span class="n">Δs</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">dotp</span></div>


<div class="viewcode-block" id="boundary_test">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.boundary_test">[docs]</a>
<span class="k">def</span> <span class="nf">boundary_test</span><span class="p">(</span><span class="n">Efuncs</span><span class="p">,</span> <span class="n">Hfuncs</span><span class="p">,</span> <span class="n">fiber_spec</span><span class="p">,</span> <span class="n">modeType</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This  function  checks  that a given solution for the fields</span>
<span class="sd">    satisfies  the  boundary  conditions  at  the  core/cladding</span>
<span class="sd">    interface within tolerance. If the mode is HE the test is on</span>
<span class="sd">    the relative difference of all field components being within</span>
<span class="sd">    tolerance. If the mode is TM or TE then the test is that all</span>
<span class="sd">    the  components  that  should  be zero are exactly zero, and</span>
<span class="sd">    that  the relative difference for the non-zero components is</span>
<span class="sd">    within tolerance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efuncs : tuple</span>
<span class="sd">        a  tuple  of  six  functions  which  describe  the three</span>
<span class="sd">        components  of  the  H  field  in  the core and cladding</span>
<span class="sd">        regions.</span>

<span class="sd">    Hfuncs : tuple </span>
<span class="sd">        a  tuple  of  six  functions  which  describe  the three</span>
<span class="sd">        components  of  the  H  field  in  the core and cladding</span>
<span class="sd">        regions.</span>

<span class="sd">    fiber_spec : dict</span>
<span class="sd">        a dictionary containing the fiber specifications.</span>

<span class="sd">    modeType : str</span>
<span class="sd">        must be one of &#39;HE&#39;, &#39;TE&#39;, or &#39;TM&#39;.</span>

<span class="sd">    tolerance :float</span>
<span class="sd">        the tolerance for the boundary condition test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boundaryTest : bool</span>
<span class="sd">        True if test OK, False otherwise.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="p">(</span><span class="n">ECoreρ</span><span class="p">,</span> <span class="n">ECoreϕ</span><span class="p">,</span> <span class="n">ECorez</span><span class="p">,</span> <span class="n">ECladdingρ</span><span class="p">,</span> <span class="n">ECladdingϕ</span><span class="p">,</span> <span class="n">ECladdingz</span><span class="p">)</span> <span class="o">=</span> <span class="n">Efuncs</span>
    <span class="p">(</span><span class="n">HCoreρ</span><span class="p">,</span> <span class="n">HCoreϕ</span><span class="p">,</span> <span class="n">HCorez</span><span class="p">,</span> <span class="n">HCladdingρ</span><span class="p">,</span> <span class="n">HCladdingϕ</span><span class="p">,</span> <span class="n">HCladdingz</span><span class="p">)</span> <span class="o">=</span> <span class="n">Hfuncs</span>
    <span class="n">nCore</span> <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;nCore&#39;</span><span class="p">]</span>
    <span class="n">nCladding</span> <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">fiber_spec</span><span class="p">[</span><span class="s1">&#39;coreRadius&#39;</span><span class="p">]</span>
    <span class="n">coreBoundary</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">claddingBoundary</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="c1"># the radial component of D is continuous,</span>
    <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;DCoreρ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECoreρ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">nCore</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;DCladdingρ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECladdingρ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">nCladding</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># the radial component of B is continuous,</span>
    <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;BCoreρ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCoreρ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;BCladdingρ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCladdingρ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># the azimuthal component of E is continuous,</span>
    <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;ECoreϕ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECoreϕ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;ECladdingϕ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECladdingϕ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># the longitudinal component of E is continuous,</span>
    <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;ECorez&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECorez</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;ECladdingz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECladdingz</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># the azimuthal component of H is continuous,</span>
    <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;HCoreϕ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCoreϕ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;HCladdingϕ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCladdingϕ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># the longitudinal component of H is continuous.</span>
    <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;HCorez&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCorez</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;HCladdingz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HCladdingz</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">coreArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coreBoundary</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">claddingArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">claddingBoundary</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">modeType</span> <span class="o">==</span> <span class="s1">&#39;HE&#39;</span><span class="p">:</span>
        <span class="n">nonZeroDiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">coreArray</span> <span class="o">/</span> <span class="n">claddingArray</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nonZeroTest</span> <span class="o">=</span> <span class="n">nonZeroDiff</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
        <span class="n">zeroCheck</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">modeType</span> <span class="o">==</span> <span class="s1">&#39;TE&#39;</span><span class="p">:</span>
        <span class="n">coreZeros</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">claddingZeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="c1"># the z-component of E should be zero</span>
        <span class="n">coreZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;ECorez&#39;</span><span class="p">]</span>
        <span class="n">claddingZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;ECladdingz&#39;</span><span class="p">]</span>
        <span class="c1"># the ρ-component of E should be zero</span>
        <span class="n">coreZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;DCoreρ&#39;</span><span class="p">]</span>
        <span class="n">claddingZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;DCladdingρ&#39;</span><span class="p">]</span>
        <span class="c1"># the ϕ-component of H should be zero</span>
        <span class="n">coreZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;HCoreϕ&#39;</span><span class="p">]</span>
        <span class="n">claddingZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;HCladdingϕ&#39;</span><span class="p">]</span>
        <span class="n">zeroCheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">coreZeros</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">claddingZeros</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Now for all the ones that should be non-zero</span>
        <span class="n">coreNonZeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">claddingNonZeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">coreNonZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;ECoreϕ&#39;</span><span class="p">]</span>
        <span class="n">claddingNonZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;ECladdingϕ&#39;</span><span class="p">]</span>
        <span class="n">coreNonZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;BCoreρ&#39;</span><span class="p">]</span>
        <span class="n">claddingNonZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;BCladdingρ&#39;</span><span class="p">]</span>
        <span class="n">coreNonZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;HCorez&#39;</span><span class="p">]</span>
        <span class="n">claddingNonZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;HCladdingz&#39;</span><span class="p">]</span>
        <span class="n">nonZeroDiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">coreNonZeros</span><span class="p">)</span><span class="o">/</span><span class="n">claddingNonZeros</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nonZeroTest</span> <span class="o">=</span> <span class="n">nonZeroDiff</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
    <span class="k">elif</span> <span class="n">modeType</span> <span class="o">==</span> <span class="s1">&#39;TM&#39;</span><span class="p">:</span>
        <span class="n">coreZeros</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">claddingZeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="c1"># the ϕ-component of E should be zero</span>
        <span class="n">coreZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;ECoreϕ&#39;</span><span class="p">]</span>
        <span class="n">claddingZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;ECladdingϕ&#39;</span><span class="p">]</span>
        <span class="c1"># the z-component of H should be zero</span>
        <span class="n">coreZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;HCorez&#39;</span><span class="p">]</span>
        <span class="n">claddingZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;HCladdingz&#39;</span><span class="p">]</span>
        <span class="c1"># the ρ-component of B should be zero</span>
        <span class="n">coreZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;BCoreρ&#39;</span><span class="p">]</span>
        <span class="n">claddingZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;BCladdingρ&#39;</span><span class="p">]</span>
        <span class="n">zeroCheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">coreZeros</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">claddingZeros</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Now for all the ones that should be non-zero</span>
        <span class="n">coreNonZeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">claddingNonZeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">coreNonZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;DCoreρ&#39;</span><span class="p">]</span>
        <span class="n">claddingNonZeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;DCladdingρ&#39;</span><span class="p">]</span>
        <span class="n">coreNonZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;ECorez&#39;</span><span class="p">]</span>
        <span class="n">claddingNonZeros</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;ECladdingz&#39;</span><span class="p">]</span>
        <span class="n">coreNonZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreBoundary</span><span class="p">[</span><span class="s1">&#39;HCoreϕ&#39;</span><span class="p">]</span>
        <span class="n">claddingNonZeros</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">claddingBoundary</span><span class="p">[</span><span class="s1">&#39;HCladdingϕ&#39;</span><span class="p">]</span>
        <span class="n">nonZeroDiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">coreNonZeros</span><span class="p">)</span><span class="o">/</span><span class="n">claddingNonZeros</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nonZeroTest</span> <span class="o">=</span> <span class="n">nonZeroDiff</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
    <span class="n">boundaryTest</span> <span class="o">=</span> <span class="p">(</span><span class="n">nonZeroTest</span> <span class="ow">and</span> <span class="n">zeroCheck</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">boundaryTest</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">claddingBoundary</span><span class="p">,</span> <span class="n">coreBoundary</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">boundaryTest</span><span class="p">,</span> <span class="n">nonZeroTest</span><span class="p">,</span> <span class="n">zeroCheck</span><span class="p">,</span> <span class="n">nonZeroDiff</span><span class="p">)</span></div>


<div class="viewcode-block" id="calculate_size_of_grid">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.calculate_size_of_grid">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_size_of_grid</span><span class="p">(</span><span class="n">fiber_sol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a solution for the modes of a multimode fiber, determine</span>
<span class="sd">    the half side of the computational domain that would capture</span>
<span class="sd">    most of the energy contained in the solved modes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fiber_sol : dict</span>
<span class="sd">        a dictionary containing the solution for the fiber.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : float</span>
<span class="sd">        the half side of the computational domain.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">goal_fraction</span> <span class="o">=</span> <span class="mf">0.99</span> 
    <span class="n">a</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;coreRadius&#39;</span><span class="p">]</span>
    <span class="n">nCore</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nCore&#39;</span><span class="p">]</span>
    <span class="n">nCladding</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span>
    <span class="n">nFree</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nFree&#39;</span><span class="p">]</span>
    <span class="n">λfree</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;λFree&#39;</span><span class="p">]</span>
    <span class="n">kFree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">λfree</span>
    <span class="n">grid_divider</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;grid_divider&#39;</span><span class="p">]</span>
    <span class="n">maxIndex</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nCore</span><span class="p">,</span> <span class="n">nCladding</span><span class="p">,</span> <span class="n">nFree</span><span class="p">)</span>
    <span class="n">Δs</span> <span class="o">=</span> <span class="n">λfree</span> <span class="o">/</span> <span class="n">maxIndex</span> <span class="o">/</span> <span class="n">grid_divider</span>
    <span class="c1"># calculate the side of the computational domain: START</span>
    <span class="n">allnums</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">modetype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;TE&#39;</span><span class="p">,</span> <span class="s1">&#39;TM&#39;</span><span class="p">,</span> <span class="s1">&#39;HE&#39;</span><span class="p">]:</span>
        <span class="n">allkzs</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="n">modetype</span> <span class="o">+</span> <span class="s1">&#39;kz&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">kzs</span> <span class="ow">in</span> <span class="n">allkzs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">kz</span> <span class="ow">in</span> <span class="n">kzs</span><span class="p">:</span>
                <span class="n">wnums</span> <span class="o">=</span> <span class="p">(</span><span class="n">modetype</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">kz</span><span class="p">)</span>
                <span class="n">allnums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wnums</span><span class="p">)</span>
    <span class="p">(</span><span class="n">modetype</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">kz</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">allnums</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">(</span><span class="n">Efuncs</span><span class="p">,</span> <span class="n">Hfuncs</span><span class="p">)</span> <span class="o">=</span> <span class="n">fieldGenerator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kFree</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">nCladding</span><span class="p">,</span> <span class="n">nCore</span><span class="p">,</span> <span class="n">modetype</span><span class="p">)</span>
    <span class="n">ρrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">λfree</span> <span class="o">/</span> <span class="n">nCladding</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">fluxCore</span> <span class="o">=</span> <span class="n">Efuncs</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">ρrange</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">Hfuncs</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">ρrange</span><span class="p">))</span> <span class="o">-</span> <span class="n">Efuncs</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">ρrange</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">Hfuncs</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">ρrange</span><span class="p">))</span>
    <span class="n">fluxCladding</span> <span class="o">=</span> <span class="n">Efuncs</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="n">ρrange</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">Hfuncs</span><span class="p">[</span><span class="mi">4</span><span class="p">](</span><span class="n">ρrange</span><span class="p">))</span> <span class="o">-</span> <span class="n">Efuncs</span><span class="p">[</span><span class="mi">4</span><span class="p">](</span><span class="n">ρrange</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">Hfuncs</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="n">ρrange</span><span class="p">))</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="n">fluxCore</span>
    <span class="n">flux</span><span class="p">[</span><span class="n">ρrange</span><span class="o">&gt;</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">fluxCladding</span><span class="p">[</span><span class="n">ρrange</span><span class="o">&gt;</span><span class="n">a</span><span class="p">]</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="n">flux</span> <span class="o">*</span> <span class="n">ρrange</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">integrand</span><span class="p">)</span>
    <span class="n">insideEnergy</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">integrand</span><span class="p">)</span><span class="o">/</span><span class="n">total</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">goal_fraction</span><span class="p">,</span> <span class="n">insideEnergy</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">)</span> <span class="o">+</span> <span class="n">λfree</span>
    <span class="n">numSigFigsina</span> <span class="o">=</span> <span class="n">sig_figs_in</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">rounder</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">numSigFigsina</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span></div>


<div class="viewcode-block" id="coordinate_layout">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.coordinate_layout">[docs]</a>
<span class="k">def</span> <span class="nf">coordinate_layout</span><span class="p">(</span><span class="n">fiber_sol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a fiber solution, return the coordinate arrays for plotting</span>
<span class="sd">    and coordinating the numerical analysis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fiber_sol : dict  with at least the following keys:</span>
<span class="sd">        &#39;coreRadius&#39; : float</span>
<span class="sd">            The radius of the core.</span>
<span class="sd">        &#39;claddingIndex&#39; : float  </span>
<span class="sd">            The refractive index of the cladding.</span>
<span class="sd">        &#39;coreIndex&#39; : float</span>
<span class="sd">            The refractive index of the core.</span>
<span class="sd">        &#39;free_space_wavelength&#39; : float</span>
<span class="sd">            The wavelength of the light in free space.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a, b, Δs, xrange, yrange, ρrange, φrange, Xg, Yg, ρg, φg, nxy, crossMask : tuple</span>
<span class="sd">        a : float</span>
<span class="sd">            The radius of the core.</span>
<span class="sd">        b : float</span>
<span class="sd">            The side of the computational domain.</span>
<span class="sd">        Δs : float</span>
<span class="sd">            The sampling resolution in the x-y direction. Assumed to be half the </span>
<span class="sd">            wavelength in the core.</span>
<span class="sd">        xrange, yrange : 1D arrays</span>
<span class="sd">            The coordinate arrays for the x-y directions.</span>
<span class="sd">        ρrange, φrange : 1D arrays</span>
<span class="sd">            The coordinate arrays for the ρ-φ directions in the cylindrical system.</span>
<span class="sd">        Xg, Yg : 2D arrays</span>
<span class="sd">            The coordinate arrays for x-y.</span>
<span class="sd">        ρg, φg : 2D arrays</span>
<span class="sd">            ρg has the values for the radial coordinate, φg has the values for the</span>
<span class="sd">            azimuthal coordinate.</span>
<span class="sd">        nxy : 2D array</span>
<span class="sd">            The refractive index profile of the waveguide.</span>
<span class="sd">        crossMask : 2D array</span>
<span class="sd">            A mask that is True where the core is and False where the cladding is.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;coreRadius&#39;</span><span class="p">]</span>
    <span class="n">nCore</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nCore&#39;</span><span class="p">]</span>
    <span class="n">nCladding</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span>
    <span class="n">nFree</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nFree&#39;</span><span class="p">]</span>
    <span class="n">λfree</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;λFree&#39;</span><span class="p">]</span>
    <span class="n">kFree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">λfree</span>
    <span class="n">grid_divider</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;grid_divider&#39;</span><span class="p">]</span>
    <span class="n">maxIndex</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nCore</span><span class="p">,</span> <span class="n">nCladding</span><span class="p">,</span> <span class="n">nFree</span><span class="p">)</span>
    <span class="n">Δs</span> <span class="o">=</span> <span class="n">λfree</span> <span class="o">/</span> <span class="n">maxIndex</span> <span class="o">/</span> <span class="n">grid_divider</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">calculate_size_of_grid</span><span class="p">(</span><span class="n">fiber_sol</span><span class="p">)</span>
    <span class="c1"># calculate the side of the computational domain: END</span>
    <span class="c1"># calculate the coordinates arrays</span>
    <span class="n">numSamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">Δs</span><span class="p">)</span>
    <span class="n">xrange</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">)</span>
    <span class="n">yrange</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">)</span>
    <span class="n">ρrange</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">)</span>
    <span class="n">φrange</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_dtype</span><span class="p">)</span>
    <span class="n">Xg</span><span class="p">,</span> <span class="n">Yg</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span><span class="p">)</span>
    <span class="n">ρg</span>         <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Yg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">φg</span>         <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Yg</span><span class="p">,</span> <span class="n">Xg</span><span class="p">)</span>

    <span class="n">crossMask</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numSamples</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool8</span><span class="p">)</span>
    <span class="n">crossMask</span><span class="p">[</span><span class="n">ρg</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">crossMask</span><span class="p">[</span><span class="n">ρg</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># #Coords-Calc</span>
    <span class="n">nxy</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numSamples</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">))</span>
    <span class="n">nxy</span><span class="p">[</span><span class="n">crossMask</span><span class="p">]</span>  <span class="o">=</span>  <span class="n">nCore</span>
    <span class="n">nxy</span><span class="p">[</span><span class="o">~</span><span class="n">crossMask</span><span class="p">]</span> <span class="o">=</span>  <span class="n">nCladding</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Δs</span><span class="p">,</span> <span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">,</span> <span class="n">φrange</span><span class="p">,</span> <span class="n">Xg</span><span class="p">,</span> <span class="n">Yg</span><span class="p">,</span> <span class="n">ρg</span><span class="p">,</span> <span class="n">φg</span><span class="p">,</span> <span class="n">nxy</span><span class="p">,</span> <span class="n">crossMask</span><span class="p">,</span> <span class="n">numSamples</span></div>


<div class="viewcode-block" id="calculate_numerical_basis">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.calculate_numerical_basis">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_numerical_basis</span><span class="p">(</span><span class="n">fiber_sol</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a solution for the propagation modes of an optical waveguide, calculate a numerical basis.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fiber_sol : dict with at least the following keys:</span>
<span class="sd">        &#39;coreRadius&#39; : float</span>
<span class="sd">            The radius of the core.</span>
<span class="sd">        &#39;nCladding&#39; : float</span>
<span class="sd">            The refractive index of the cladding.</span>
<span class="sd">        &#39;nCore&#39; : float</span>
<span class="sd">            The refractive index of the core.</span>
<span class="sd">        &#39;free_space_wavelength&#39; : float</span>
<span class="sd">            The wavelength of the light in free space.</span>
<span class="sd">        &#39;totalModes&#39; : int</span>
<span class="sd">            The total number of calculated modes.</span>
<span class="sd">        &#39;TEkz&#39; : 1D dict</span>
<span class="sd">            A single key equal to m=0, the values are array with</span>
<span class="sd">            the TE modes propagation constants.</span>
<span class="sd">        &#39;TMkz&#39; : 1D dict</span>
<span class="sd">            A single key equal to m=0, the values are array with</span>
<span class="sd">            the TM modes propagation constants.</span>
<span class="sd">        &#39;HEkz&#39; : 1D dict</span>
<span class="sd">            Keys are m values, values are 1D arrays of kz values.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fiber_sol : dict the same dictionary as the input, but with two new keys:</span>
<span class="sd">        &#39;coord_layout&#39; : tuple</span>
<span class="sd">            The tuple returned by the coordinate_layout function.</span>
<span class="sd">        &#39;eigenbasis&#39; : 5D np.array</span>
<span class="sd">            The numerical basis. The first dimension is the mode number,</span>
<span class="sd">            the second dimension only has two values, 0 and 1, 0 for the</span>
<span class="sd">            E  field, and 1 for the H field. The third dimension is used</span>
<span class="sd">            for  the  different components of the corresponding field in</span>
<span class="sd">            cylindrical  coordinates.  The  first index being the radial</span>
<span class="sd">            component,  the  second index being the azimuthal component,</span>
<span class="sd">            and  the  third  index  being  the  z component. Finally the</span>
<span class="sd">            fourth  and fifth dimensions are arrays that hold the values</span>
<span class="sd">            of   the  corresponding  field  components.  The  modes  are</span>
<span class="sd">            enumerated  such that first all TE modes are given, then all</span>
<span class="sd">            TM modes, and finally all HE modes. This same enumeration is</span>
<span class="sd">            the one used for the &#39;eigenbasis_nums&#39; key.</span>
<span class="sd">        &#39;eigenbasis_nums&#39; : list of tuples</span>
<span class="sd">            A  list  of tuples, each tuple has 7 values, the first value</span>
<span class="sd">            is  a  string indicating the type of mode, and can be either</span>
<span class="sd">            &#39;TE&#39;, &#39;TM&#39;, or &#39;HE&#39;. The second value is a string indicating</span>
<span class="sd">            the  parity  of the mode. The third value is the value of m.</span>
<span class="sd">            The  fourth  value  corresponds  to  the  value  of  kz, the</span>
<span class="sd">            propagation  constant along the z-direction. The fifth value</span>
<span class="sd">            is   the   index  that  the  value  of  kz  has  within  the</span>
<span class="sd">            corresponding  array  listing the propagation constants. The</span>
<span class="sd">            sixth  value  is  the transverse propagation constant inside</span>
<span class="sd">            the  core.  The seventh value is the propagation constant in</span>
<span class="sd">            the cladding. (modType, parity, m, kzidx, kz, γ, β)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;invalid value encountered in sqrt&#39;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;invalid value encountered in multiply&#39;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;invalid value encountered in divide&#39;</span><span class="p">)</span>
    <span class="n">coord_layout</span> <span class="o">=</span> <span class="n">coordinate_layout</span><span class="p">(</span><span class="n">fiber_sol</span><span class="p">)</span>
    <span class="n">nCore</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nCore&#39;</span><span class="p">]</span>
    <span class="n">nCladding</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span>
    <span class="n">λfree</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;λFree&#39;</span><span class="p">]</span>
    <span class="n">kFree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">λfree</span>
    <span class="k">if</span> <span class="s1">&#39;coord_layout&#39;</span> <span class="ow">in</span> <span class="n">fiber_sol</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;coord_layout&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;eigenbasis&#39;</span> <span class="ow">in</span> <span class="n">fiber_sol</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;eigenbasis&#39;</span><span class="p">]</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Δs</span><span class="p">,</span> <span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">,</span> <span class="n">φrange</span><span class="p">,</span> <span class="n">Xg</span><span class="p">,</span> <span class="n">Yg</span><span class="p">,</span> <span class="n">ρg</span><span class="p">,</span> <span class="n">φg</span><span class="p">,</span> <span class="n">nxy</span><span class="p">,</span> <span class="n">crossMask</span><span class="p">,</span> <span class="n">numSamples</span> <span class="o">=</span> <span class="n">coord_layout</span>
    <span class="c1"># determine how many modes there are in total</span>
    <span class="n">totalModes</span> <span class="o">=</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;totalModes&#39;</span><span class="p">]</span>
    <span class="n">eigenbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">totalModes</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">),</span>  <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">eigenbasis_nums</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">iter_fun</span> <span class="o">=</span> <span class="n">tqdm</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">iter_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">modType</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;TE&#39;</span><span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">,</span><span class="s1">&#39;HE&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">modType</span> <span class="o">==</span> <span class="s1">&#39;HE&#39;</span><span class="p">:</span>
            <span class="n">parities</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;EVEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ODD&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parities</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TETM&#39;</span><span class="p">]</span>
        <span class="n">solkey</span> <span class="o">=</span> <span class="n">modType</span> <span class="o">+</span> <span class="s1">&#39;kz&#39;</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">kzs</span> <span class="ow">in</span> <span class="n">fiber_sol</span><span class="p">[</span><span class="n">solkey</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cosMesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">φg</span><span class="p">)</span>
            <span class="n">sinMesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">φg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kzidx</span><span class="p">,</span> <span class="n">kz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iter_fun</span><span class="p">(</span><span class="n">kzs</span><span class="p">)):</span>
                <span class="n">γ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nCore</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">λfree</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">β</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kz</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">nCladding</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">λfree</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="n">Efuncs</span><span class="p">,</span> <span class="n">Hfuncs</span><span class="p">)</span> <span class="o">=</span> <span class="n">fieldGenerator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kFree</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">nCladding</span><span class="p">,</span> <span class="n">nCore</span><span class="p">,</span> <span class="n">modType</span><span class="p">)</span>
                <span class="p">(</span><span class="n">ECoreρ</span><span class="p">,</span> <span class="n">ECoreϕ</span><span class="p">,</span> <span class="n">ECorez</span><span class="p">,</span> <span class="n">ECladdingρ</span><span class="p">,</span> <span class="n">ECladdingϕ</span><span class="p">,</span> <span class="n">ECladdingz</span><span class="p">)</span> <span class="o">=</span> <span class="n">Efuncs</span>
                <span class="p">(</span><span class="n">HCoreρ</span><span class="p">,</span> <span class="n">HCoreϕ</span><span class="p">,</span> <span class="n">HCorez</span><span class="p">,</span> <span class="n">HCladdingρ</span><span class="p">,</span> <span class="n">HCladdingϕ</span><span class="p">,</span> <span class="n">HCladdingz</span><span class="p">)</span> <span class="o">=</span> <span class="n">Hfuncs</span>
                <span class="n">funPairs</span> <span class="o">=</span> <span class="p">(((</span><span class="n">ECoreρ</span><span class="p">,</span> <span class="n">ECladdingρ</span><span class="p">),</span> <span class="p">(</span><span class="n">HCoreρ</span><span class="p">,</span> <span class="n">HCladdingρ</span><span class="p">)),</span>
                            <span class="p">((</span><span class="n">ECoreϕ</span><span class="p">,</span> <span class="n">ECladdingϕ</span><span class="p">),</span> <span class="p">(</span><span class="n">HCoreϕ</span><span class="p">,</span> <span class="n">HCladdingϕ</span><span class="p">)),</span>
                            <span class="p">((</span><span class="n">ECorez</span><span class="p">,</span> <span class="n">ECladdingz</span><span class="p">),</span> <span class="p">(</span><span class="n">HCorez</span><span class="p">,</span> <span class="n">HCladdingz</span><span class="p">)))</span>
                <span class="n">this_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
                <span class="n">this_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">((</span><span class="n">EfunCore</span><span class="p">,</span> <span class="n">EfunCladding</span><span class="p">),</span> <span class="p">(</span><span class="n">HfunCore</span><span class="p">,</span> <span class="n">HfunCladding</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">funPairs</span><span class="p">):</span>
                    <span class="n">ECorevals</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">EfunCore</span><span class="p">)(</span><span class="n">ρrange</span><span class="p">)</span>
                    <span class="n">ECorevals</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ρg</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">,</span> <span class="n">ECorevals</span><span class="p">)</span>
                    <span class="n">ECorevals</span><span class="p">[</span><span class="o">~</span><span class="n">crossMask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ECladdingvals</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">EfunCladding</span><span class="p">)(</span><span class="n">ρrange</span><span class="p">)</span>
                    <span class="n">ECladdingvals</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ρg</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">,</span> <span class="n">ECladdingvals</span><span class="p">)</span>
                    <span class="n">ECladdingvals</span><span class="p">[</span><span class="n">crossMask</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">E_all</span>                  <span class="o">=</span> <span class="n">ECorevals</span> <span class="o">+</span> <span class="n">ECladdingvals</span>
                    <span class="n">HCorevals</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">HfunCore</span><span class="p">)(</span><span class="n">ρrange</span><span class="p">)</span>
                    <span class="n">HCorevals</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ρg</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">,</span> <span class="n">HCorevals</span><span class="p">)</span>
                    <span class="n">HCorevals</span><span class="p">[</span><span class="o">~</span><span class="n">crossMask</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">HCladdingvals</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">HfunCladding</span><span class="p">)(</span><span class="n">ρrange</span><span class="p">)</span>
                    <span class="n">HCladdingvals</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ρg</span><span class="p">,</span> <span class="n">ρrange</span><span class="p">,</span> <span class="n">HCladdingvals</span><span class="p">)</span>
                    <span class="n">HCladdingvals</span><span class="p">[</span><span class="n">crossMask</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">H_all</span>                  <span class="o">=</span> <span class="n">HCorevals</span> <span class="o">+</span> <span class="n">HCladdingvals</span>
                    <span class="n">E_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">E_all</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
                    <span class="n">H_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">H_all</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
                    <span class="n">this_E</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">E_all</span>
                    <span class="n">this_H</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">H_all</span>
                <span class="k">for</span> <span class="n">parity</span> <span class="ow">in</span> <span class="n">parities</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parity</span> <span class="o">==</span> <span class="s1">&#39;TETM&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">this_E</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">this_H</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">parity</span> <span class="o">==</span> <span class="s1">&#39;EVEN&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="n">ϕPhaseE</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">cosMesh</span><span class="p">,</span>  
                                       <span class="mi">1</span><span class="p">:</span> <span class="o">-</span><span class="n">sinMesh</span><span class="p">,</span>
                                       <span class="mi">2</span><span class="p">:</span> <span class="n">cosMesh</span><span class="p">}[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="n">ϕPhaseH</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="n">sinMesh</span><span class="p">,</span>  
                                    <span class="mi">1</span><span class="p">:</span> <span class="n">cosMesh</span><span class="p">,</span>
                                    <span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="n">sinMesh</span><span class="p">}[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">this_E</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ϕPhaseE</span>
                            <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">this_H</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ϕPhaseH</span>
                    <span class="k">elif</span> <span class="n">parity</span> <span class="o">==</span> <span class="s1">&#39;ODD&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="n">ϕPhaseE</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sinMesh</span><span class="p">,</span>
                                    <span class="mi">1</span><span class="p">:</span> <span class="n">cosMesh</span><span class="p">,</span> 
                                    <span class="mi">2</span><span class="p">:</span> <span class="n">sinMesh</span><span class="p">}[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="n">ϕPhaseH</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">cosMesh</span><span class="p">,</span>
                                    <span class="mi">1</span><span class="p">:</span> <span class="n">sinMesh</span><span class="p">,</span> 
                                    <span class="mi">2</span><span class="p">:</span> <span class="n">cosMesh</span><span class="p">}[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">this_E</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ϕPhaseE</span>
                            <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">this_H</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ϕPhaseH</span>
                    <span class="c1"># normalize the field</span>
                    <span class="n">E_field</span> <span class="o">=</span> <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">H_field</span> <span class="o">=</span> <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">norm_sq</span> <span class="o">=</span> <span class="n">field_dot</span><span class="p">(</span><span class="n">E_field</span><span class="p">,</span> <span class="n">H_field</span><span class="p">,</span> <span class="n">Δs</span><span class="p">)</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_sq</span><span class="p">)</span>
                    <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span>
                    <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenbasis</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span>
                    <span class="n">eigenbasis_nums</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">modType</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">kzidx</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">γ</span><span class="p">,</span> <span class="n">β</span><span class="p">))</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;eigenbasis&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">eigenbasis</span>
    <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;coord_layout&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">coord_layout</span>
    <span class="n">fiber_sol</span><span class="p">[</span><span class="s1">&#39;eigenbasis_nums&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenbasis_nums</span>
    <span class="k">return</span> <span class="n">fiber_sol</span></div>


<div class="viewcode-block" id="poyntingrefractor">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.poyntingrefractor">[docs]</a>
<span class="k">def</span> <span class="nf">poyntingrefractor</span><span class="p">(</span><span class="n">Efield</span><span class="p">,</span> <span class="n">Hfield</span><span class="p">,</span> <span class="n">nxy</span><span class="p">,</span> <span class="n">nFree</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Approximate  the  refracted  field across a planar interface</span>
<span class="sd">    using  the Poynting vector as an analog to the wavevector of</span>
<span class="sd">    a plane-wave.</span>

<span class="sd">    Any  evanescent  fields  are  ignored. All cases where there</span>
<span class="sd">    would  be  total  internal reflection the refracted field is</span>
<span class="sd">    set to zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efield : np.array (3, N, M)</span>
<span class="sd">        The electric field incident on the interface.</span>
<span class="sd">    Hfield : np.array (3, N, M)</span>
<span class="sd">        The H-field incident on the interface.</span>
<span class="sd">    nxy : np.array    (N, M)</span>
<span class="sd">        The refractive index transverse to the interface inside the incident medium.</span>
<span class="sd">    nFree : float</span>
<span class="sd">        The refractive index of the homogeneous refractive medium.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Whether to print or not progress messages, by default False.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Eref, Href : tuple of np.array (3, N, M)</span>
<span class="sd">        The refracted electric and magnetic fields.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># #EXH-Calc</span>
    <span class="c1"># calculate the Poynting vector</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the Poynting vector field...&quot;</span><span class="p">)</span>
    <span class="n">Sfield</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Efield</span><span class="p">,</span> <span class="n">Hfield</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># #normIncidentk-Calc</span>
    <span class="c1"># calculate the magnitude of the Poynting field</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the magnitude of the Poynting field...&quot;</span><span class="p">)</span>
    <span class="n">Sfieldmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Sfield</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the transverse component of the Poynting field...&quot;</span><span class="p">)</span>
    <span class="c1"># calculate the unit vector in the direction of the Poynting vector</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the unit vector in the direction of the Poynting vector...&quot;</span><span class="p">)</span>
    <span class="n">kfield</span> <span class="o">=</span> <span class="n">Sfield</span> <span class="o">/</span> <span class="n">Sfieldmag</span>
    <span class="c1"># calculate the transverse component of the Poynting vector</span>
    <span class="n">Stransverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Sfield</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Sfield</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># #β-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the angle of incidence field...&quot;</span><span class="p">)</span>
    <span class="c1"># Assuming that the normal is pointing in the +z direction</span>
    <span class="n">βfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Stransverse</span><span class="p">,</span> <span class="n">Sfield</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="c1"># #θ-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the angle of refraction field...&quot;</span><span class="p">)</span>
    <span class="n">θfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">nxy</span><span class="o">/</span><span class="n">nFree</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">βfield</span><span class="p">))</span>

    <span class="c1"># #FresnelS-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the Fresnel coefficients...&quot;</span><span class="p">)</span>
    
    <span class="n">fresnelS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nxy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">βfield</span><span class="p">)</span> 
                <span class="o">/</span> <span class="p">(</span> <span class="n">nxy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">βfield</span><span class="p">)</span> 
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nFree</span><span class="o">**</span><span class="mi">2</span> 
                                <span class="o">-</span> <span class="n">nxy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">βfield</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
    
    <span class="c1"># #FresnelP-Calc</span>
    <span class="n">fresnelP</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nFree</span> <span class="o">*</span> <span class="n">nxy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">βfield</span><span class="p">)</span> 
                <span class="o">/</span> <span class="p">(</span><span class="n">nFree</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">βfield</span><span class="p">)</span> 
                <span class="o">+</span>  <span class="n">nxy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nFree</span><span class="o">**</span><span class="mi">2</span> 
                            <span class="o">-</span> <span class="n">nxy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">βfield</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
    
    <span class="c1"># #ζ-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the ζ of the local coord system...&quot;</span><span class="p">)</span>
    <span class="c1"># calculate the unit vector field perpendicular to the plane of incidence</span>
    <span class="c1"># which is basically k X z</span>
    <span class="n">ζfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">kfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># normalize it</span>
    <span class="n">ζfield</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ζfield</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># in the case of normal incidence, the ζ is not defined</span>
    <span class="c1"># so it can be set to the unit vector in the first direction</span>
    <span class="n">normalIncidence</span> <span class="o">=</span> <span class="p">(</span><span class="n">βfield</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">normalIncidence</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">normalIncidence</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ζfield</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">normalIncidence</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># #EincS-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the S and P component of the incident electric field...&quot;</span><span class="p">)</span>
    <span class="c1"># decompose the field in P and S polarizations</span>
    <span class="c1"># first find P-pol and then use the complement to determine S-pol</span>
    <span class="c1"># the S-pol can be obtained by the dot product of E with ζ</span>
    <span class="n">ESdot</span> <span class="o">=</span> <span class="n">Efield</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Efield</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">EincS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ζfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">EincS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESdot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">EincS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESdot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># #EincP-Calc</span>
    <span class="n">EincP</span> <span class="o">=</span> <span class="n">Efield</span> <span class="o">-</span> <span class="n">EincS</span>
    <span class="k">del</span> <span class="n">ESdot</span>

    <span class="c1"># #HincS-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the S and P component of the incident H field...&quot;</span><span class="p">)</span>
    <span class="c1"># decompose the field in P and S polarizations</span>
    <span class="c1"># first find P-pol and then use the complement to determine S-pol</span>
    <span class="c1"># the S-pol can be obtained by the dot product of H with ζ</span>
    <span class="n">HSdot</span> <span class="o">=</span> <span class="n">Hfield</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Hfield</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">HincS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ζfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">HincS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">HSdot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">HincS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">HSdot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># #HincP-Calc</span>
    <span class="n">HincP</span> <span class="o">=</span> <span class="n">Hfield</span> <span class="o">-</span> <span class="n">HincS</span>
    <span class="k">del</span> <span class="n">HSdot</span>

    <span class="c1"># #ErefS-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the S and P component of the refracted electric field...&quot;</span><span class="p">)</span>
    <span class="n">ErefS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Efield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ErefS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fresnelS</span> <span class="o">*</span> <span class="n">EincS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ErefS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fresnelS</span> <span class="o">*</span> <span class="n">EincS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ErefS</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fresnelS</span> <span class="o">*</span> <span class="n">EincS</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ErefS</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ErefS</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># #HrefS-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the S and P component of the refracted H field...&quot;</span><span class="p">)</span>
    <span class="n">HrefS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Hfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">HrefS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxy</span> <span class="o">/</span> <span class="n">nFree</span><span class="p">)</span> <span class="o">*</span> <span class="n">fresnelP</span> <span class="o">*</span> <span class="n">HincS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">HrefS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxy</span> <span class="o">/</span> <span class="n">nFree</span><span class="p">)</span> <span class="o">*</span> <span class="n">fresnelP</span> <span class="o">*</span> <span class="n">HincS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">HrefS</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxy</span> <span class="o">/</span> <span class="n">nFree</span><span class="p">)</span> <span class="o">*</span> <span class="n">fresnelP</span> <span class="o">*</span> <span class="n">HincS</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">HrefS</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">HrefS</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># #ErefP-Calc</span>
    <span class="n">ErefP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Efield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ErefP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fresnelP</span> <span class="o">*</span> <span class="n">EincP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ErefP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fresnelP</span> <span class="o">*</span> <span class="n">EincP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ErefP</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fresnelP</span> <span class="o">*</span> <span class="n">EincP</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ErefP</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ErefP</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># #HrefP-Calc</span>
    <span class="n">HrefP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Hfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">HrefP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxy</span> <span class="o">/</span> <span class="n">nFree</span><span class="p">)</span> <span class="o">*</span> <span class="n">fresnelS</span> <span class="o">*</span> <span class="n">HincP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">HrefP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxy</span> <span class="o">/</span> <span class="n">nFree</span><span class="p">)</span> <span class="o">*</span> <span class="n">fresnelS</span> <span class="o">*</span> <span class="n">HincP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">HrefP</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxy</span> <span class="o">/</span> <span class="n">nFree</span><span class="p">)</span> <span class="o">*</span> <span class="n">fresnelS</span> <span class="o">*</span> <span class="n">HincP</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">HrefP</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">HrefP</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># #Eref-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the total refracted electric field...&quot;</span><span class="p">)</span>
    <span class="n">Eref</span>  <span class="o">=</span> <span class="n">ErefS</span> <span class="o">+</span> <span class="n">ErefP</span>

    <span class="c1"># #Href-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the total refracted H field...&quot;</span><span class="p">)</span>
    <span class="n">Href</span>  <span class="o">=</span> <span class="n">HrefS</span> <span class="o">+</span> <span class="n">HrefP</span>

    <span class="c1"># #kref-Calc</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the refracted wavevector (normalized) field...&quot;</span><span class="p">)</span>
    <span class="n">ξfield</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ζfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ξfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ζfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ξfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ζfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">kref</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kfield</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">kref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">θfield</span><span class="p">)</span> <span class="o">*</span> <span class="n">ξfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">kref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">θfield</span><span class="p">)</span> <span class="o">*</span> <span class="n">ξfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">kref</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">θfield</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kref</span><span class="p">,</span> <span class="n">Eref</span><span class="p">,</span> <span class="n">Href</span></div>



<div class="viewcode-block" id="from_cyl_cart_to_cart_cart">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.from_cyl_cart_to_cart_cart">[docs]</a>
<span class="k">def</span> <span class="nf">from_cyl_cart_to_cart_cart</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given  a  field  in  cylindrical  coordinates, convert it to</span>
<span class="sd">    cartesian  coordinates.  The  given  field  is assumed to be</span>
<span class="sd">    anchored  to a cartesian coordinate system in the sense that</span>
<span class="sd">    each  of the indices in its array corresponds to a cartesian</span>
<span class="sd">    grid  in the usual sense but the value of the vector at that</span>
<span class="sd">    position is given in terms of cylindrical coordinates.</span>

<span class="sd">    This  function  assumes  that  the  region  described by the</span>
<span class="sd">    cartesian coordinates is a square centered on the axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : np.array</span>
<span class="sd">        A  field  in  cylindrical  coordinates  with  shape  (3,</span>
<span class="sd">        numSamples,  numSamples) the indices being the ρ, φ, and</span>
<span class="sd">        z components respectively.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ccfield : np.array</span>
<span class="sd">        A   field   in  cartesian  coordinates  with  shape  (3,</span>
<span class="sd">        numSamples,  numSamples) the indices being the x, y, and</span>
<span class="sd">        z components respectively of the given vector field.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">yrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">Xg</span><span class="p">,</span> <span class="n">Yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span><span class="p">)</span>
    <span class="n">φg</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Yg</span><span class="p">,</span> <span class="n">Xg</span><span class="p">)</span>
    <span class="n">ccfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ccfield</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># create the cartesian coordinates of the cylindrical unit vector fields</span>
    <span class="c1"># first for the ρ component</span>
    <span class="n">uρ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">uρ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="n">uρ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="c1"># now for the φ component</span>
    <span class="n">uφ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">uφ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="n">uφ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="c1"># using these convert the cylindrical components to cartesian</span>
    <span class="c1"># adding the x components of what comes from the two unit vectors</span>
    <span class="c1"># scaled up by the field values in the cylindrical basis</span>
    <span class="n">ccfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">uρ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">uφ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ccfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">uρ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">uφ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ccfield</span></div>


<div class="viewcode-block" id="from_cart_cart_to_cyl_cart">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.from_cart_cart_to_cyl_cart">[docs]</a>
<span class="k">def</span> <span class="nf">from_cart_cart_to_cyl_cart</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given  a  field  in  cartesian  coordinates,  convert  it to</span>
<span class="sd">    cylindrical  coordinates.  This assumes that the given field</span>
<span class="sd">    represents   the   vector  field  in  cartesian  coordinates</span>
<span class="sd">    anchored  in  a  centered  cartesian grid. The function then</span>
<span class="sd">    returns  a  field that would be sampled in the same centered</span>
<span class="sd">    cartesian  grid,  but  the field values are now given in the</span>
<span class="sd">    associated cylindrical coordinate system.</span>

<span class="sd">    ATTENTION:  This  function assumes that the region described</span>
<span class="sd">    by  the  cartesian  coordinates  is a square centered on the</span>
<span class="sd">    axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : np.array</span>
<span class="sd">        A   field   in  cartesian  coordinates  with  shape  (3,</span>
<span class="sd">        numSamples,  numSamples) the indices being the x, y, and</span>
<span class="sd">        z components respectively of the given vector field.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cylfield : np.array</span>
<span class="sd">        A  field  in  cylindrical  coordinates  with  shape  (3,</span>
<span class="sd">        numSamples,  numSamples) the indices being the ρ, φ, and</span>
<span class="sd">        z components respectively.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">yrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">Xg</span><span class="p">,</span> <span class="n">Yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span><span class="p">)</span>
    <span class="n">φg</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Yg</span><span class="p">,</span> <span class="n">Xg</span><span class="p">)</span>
    <span class="n">cylfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">cylfield</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># create the cylindrical coordinates of the cartesian unit vector fields</span>
    <span class="c1"># first for the x component</span>
    <span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">ux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="n">ux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="c1"># now for the y component</span>
    <span class="n">uy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">uy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="n">uy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">φg</span><span class="p">)</span>
    <span class="c1"># using these convert the cartesian components to cylindrical</span>
    <span class="c1"># adding the ρ components of what comes from the two unit vectors</span>
    <span class="c1"># scaled up by the field values in the cartesian basis</span>
    <span class="n">cylfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">uy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cylfield</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">uy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cylfield</span></div>


<div class="viewcode-block" id="angular_farfield_propagator">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.angular_farfield_propagator">[docs]</a>
<span class="k">def</span> <span class="nf">angular_farfield_propagator</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">λFree</span><span class="p">,</span> <span class="n">nMedium</span><span class="p">,</span> <span class="n">Zf</span><span class="p">,</span> <span class="n">Zi</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">Δf</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;This function approximates the farfield of a field given the nearfield</span>
<span class="sd">    and the propagation distance.</span>

<span class="sd">    This is done by using the angular spectrum method. In which the Fourier</span>
<span class="sd">    transform of the nearfield is understood to describe the coeffients that</span>
<span class="sd">    approximate the farfield as the superposition of plane waves.</span>

<span class="sd">    It assumes that the nearfield is given on a square grid perpendicular to</span>
<span class="sd">    the z-axis. The farfield is also given on a square grid perpendicular to</span>
<span class="sd">    the z-axis.</span>

<span class="sd">    The farfield is approximated by the following formula:</span>
<span class="sd">    Efar = (2π 1j / kFree) * ((Zf-Zi)/Rfsq) * np.exp(1j*kFree*Rf) * S2</span>
<span class="sd">    with S2 equal to the Fourier transform extrapolated to the position</span>
<span class="sd">    of the farfield.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : np.array (3, Ni, Ni) or (Ni, Ni) or (1, Ni, Ni)</span>
<span class="sd">        An array describing the nearfield of the field to be propagated.</span>
<span class="sd">    nMedium : float</span>
<span class="sd">        Refractive index of the homogenous medium or propagation.</span>
<span class="sd">    Zf : float</span>
<span class="sd">        The z-coordinate of the farfield.</span>
<span class="sd">    Zi : float</span>
<span class="sd">        The z-coordinate of the nearfield.</span>
<span class="sd">    si : float</span>
<span class="sd">        The size of the nearfield.</span>
<span class="sd">    sf : float</span>
<span class="sd">        The size of the farfield.</span>
<span class="sd">    Δf : float (optional)</span>
<span class="sd">        Spatial resolution of the farfield. If None, it is set to Δi.</span>
<span class="sd">    options : dict (optional) A dictionary of options:</span>
<span class="sd">        &#39;return_fourier&#39; : bool</span>
<span class="sd">            If True, the function also returns the Fourier transform of the</span>
<span class="sd">            nearfield.</span>
<span class="sd">        &#39;return_as_dict&#39; : bool</span>
<span class="sd">            If False, the function returns the two arrays in the same order</span>
<span class="sd">            as the keys in the dictionary.</span>
<span class="sd">            If True, the function returns a dictionary with the following</span>
<span class="sd">            keys:</span>
<span class="sd">            &#39;Efar&#39; : np.array (3, Nf, Nf) The farfield of the field.</span>
<span class="sd">            &#39;Efourier&#39; : np.array (3, Ni, Ni) The Fourier transform of the nearfield.</span>
<span class="sd">               </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Return depends on the options dictionary, see above.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">rmin</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Zf</span> <span class="o">-</span> <span class="n">Zi</span><span class="p">)</span>
    <span class="n">rmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rmin</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">si</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sf</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">λmedium</span> <span class="o">=</span> <span class="n">λFree</span><span class="o">/</span><span class="n">nMedium</span>
    <span class="k">if</span> <span class="n">rmax</span> <span class="o">-</span> <span class="n">rmin</span> <span class="o">&gt;</span> <span class="n">λmedium</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ATTENTION: </span><span class="si">{</span><span class="p">(</span><span class="n">rmax</span><span class="o">-</span><span class="n">rmin</span><span class="p">)</span><span class="o">/</span><span class="n">λmedium</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> = (rmax - rmin) / λmedium &gt; 1. The angular spectrum approximation is problematic.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Consider decreasing si, decreasing sf, or increasing Zf.&quot;</span><span class="p">)</span>
    <span class="n">all_options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;return_fourier&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="s1">&#39;return_as_dict&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="nb">globals</span><span class="p">()[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">globals</span><span class="p">()[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">c</span>     <span class="o">=</span> <span class="mi">1</span>
    <span class="n">κ</span>     <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 2 * np.pi</span>
    <span class="n">ω</span>     <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">λFree</span>
    <span class="n">kFree</span> <span class="o">=</span> <span class="n">ω</span><span class="o">*</span><span class="n">nMedium</span><span class="o">/</span><span class="n">c</span>
    <span class="n">far_out</span> <span class="o">=</span> <span class="n">kFree</span><span class="o">*</span><span class="n">rmin</span>
    <span class="k">assert</span> <span class="n">far_out</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kr = </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">kFree</span><span class="o">*</span><span class="n">rmin</span><span class="p">)</span><span class="si">}</span><span class="s1"> too small for angular-spectrum approximation.&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">field</span><span class="p">])</span>
    <span class="n">num_components</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Ni</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># spatial resolution in the nearfield</span>
    <span class="n">Δi</span>    <span class="o">=</span> <span class="n">si</span><span class="o">/</span><span class="n">Ni</span>
    <span class="k">if</span> <span class="n">Δf</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># reduces the resolution of the farfield so that both fields</span>
        <span class="c1"># have the same number of samples</span>
        <span class="n">Δf</span>    <span class="o">=</span> <span class="n">Δi</span> <span class="o">*</span> <span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="n">si</span><span class="p">)</span>
        <span class="n">Nf</span>    <span class="o">=</span> <span class="n">Ni</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># number of samples in each dir of farfield</span>
        <span class="n">Nf</span>    <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sf</span><span class="o">/</span><span class="n">Δf</span><span class="p">))</span>
    <span class="c1"># coordinate layout for the nearfield</span>
    <span class="n">xi</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">si</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">si</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ni</span><span class="p">)</span>
    <span class="n">yi</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">si</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">si</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ni</span><span class="p">)</span>
    <span class="c1"># coordinate layout for the farfield</span>
    <span class="n">xf</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sf</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sf</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nf</span><span class="p">)</span>
    <span class="n">yf</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sf</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sf</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nf</span><span class="p">)</span>
    <span class="c1"># coordinate arrays in the farfield</span>
    <span class="n">Xf</span><span class="p">,</span> <span class="n">Yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">)</span>
    <span class="c1"># the square of the distance from the center of neafield to the farfield</span>
    <span class="n">Rfsq</span>  <span class="o">=</span> <span class="n">Xf</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Yf</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Zf</span><span class="o">-</span><span class="n">Zi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># the distance itself</span>
    <span class="n">Rf</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Rfsq</span><span class="p">)</span>
    <span class="c1"># The direction cosines at the farfield</span>
    <span class="n">XfoRf</span> <span class="o">=</span> <span class="n">κ</span> <span class="o">*</span> <span class="n">Xf</span><span class="o">/</span><span class="n">Rf</span>
    <span class="n">YfoRf</span> <span class="o">=</span> <span class="n">κ</span> <span class="o">*</span> <span class="n">Yf</span><span class="o">/</span><span class="n">Rf</span>
    <span class="c1"># A factor that is common to all components of the farfield</span>
    <span class="n">S1</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="n">kFree</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">Zf</span><span class="o">-</span><span class="n">Zi</span><span class="p">)</span><span class="o">/</span><span class="n">Rfsq</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">kFree</span><span class="o">*</span><span class="n">Rf</span><span class="p">)</span>
    <span class="c1"># Spatial frequencies of the FFT</span>
    <span class="n">kx</span>    <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">Δi</span><span class="p">))</span>
    <span class="n">kx</span>    <span class="o">=</span> <span class="n">κ</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">kx</span><span class="p">)</span>
    <span class="n">ky</span>    <span class="o">=</span> <span class="n">kx</span>
    <span class="c1"># Meshgrid of spatial frequencies</span>
    <span class="n">Kx</span><span class="p">,</span> <span class="n">Ky</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">)</span>
    <span class="c1"># Initialize the farfield</span>
    <span class="n">Efar</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_components</span><span class="p">,</span> <span class="n">Nf</span><span class="p">,</span> <span class="n">Nf</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_fourier</span><span class="p">:</span>
        <span class="n">Efourier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_components</span><span class="p">,</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">Ni</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">field_component</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_components</span><span class="p">):</span>
        <span class="n">afield</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">field_component</span><span class="p">]</span>
        <span class="n">Eifou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">afield</span><span class="p">)</span>
        <span class="n">Eifou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">Eifou</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_fourier</span><span class="p">:</span>
            <span class="n">Efourier</span><span class="p">[</span><span class="n">field_component</span><span class="p">]</span> <span class="o">=</span> <span class="n">Eifou</span>
        <span class="n">S2interpolator</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">((</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">),</span> <span class="n">Eifou</span><span class="p">)</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">S2interpolator</span><span class="p">((</span><span class="n">XfoRf</span><span class="p">,</span> <span class="n">YfoRf</span><span class="p">))</span>
        <span class="n">Efar</span><span class="p">[</span><span class="n">field_component</span><span class="p">]</span> <span class="o">=</span> <span class="n">S1</span> <span class="o">*</span> <span class="n">S2</span>
    <span class="k">if</span> <span class="n">return_as_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_fourier</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;farfield&#39;</span><span class="p">:</span> <span class="n">Efar</span><span class="p">,</span> <span class="s1">&#39;fourier&#39;</span><span class="p">:</span> <span class="n">Efourier</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;farfield&#39;</span><span class="p">:</span> <span class="n">Efar</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_fourier</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Efar</span><span class="p">,</span> <span class="n">Efourier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Efar</span></div>


<div class="viewcode-block" id="device_layout">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.device_layout">[docs]</a>
<span class="k">def</span> <span class="nf">device_layout</span><span class="p">(</span><span class="n">device_design</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function creates a figure representing the device layout.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    device_design : dict with at least the following keys:</span>
<span class="sd">        coreRadius : float</span>
<span class="sd">            the radius of the core in μm</span>
<span class="sd">        mlRadius : float</span>
<span class="sd">            the radius of the metalens in μm</span>
<span class="sd">        Δ : float</span>
<span class="sd">            the distance between the end face of the</span>
<span class="sd">            fiber and the start of the metalens in μm</span>
<span class="sd">        mlPitch : float</span>
<span class="sd">            the pitch of the metalens in μm</span>
<span class="sd">        emDepth : float</span>
<span class="sd">            the  depth of the emitter in the</span>
<span class="sd">            crystal  host  in μm, measured from the base of the</span>
<span class="sd">            metalens pillars</span>
<span class="sd">        emΔxy : float</span>
<span class="sd">            the lateral uncertainty (in μm) in</span>
<span class="sd">            the position of the emitter</span>
<span class="sd">        emΔz : float</span>
<span class="sd">            the uncertainty in the axial position</span>
<span class="sd">            of the emitter in μm</span>
<span class="sd">        mlHeight : float</span>
<span class="sd">            the height of the metalens in μm</span>
<span class="sd">        λFree  : float</span>
<span class="sd">            the  free-space  wavelength of the</span>
<span class="sd">            emitter in μm</span>
<span class="sd">        nCore : float</span>
<span class="sd">            the refractive index of the core</span>
<span class="sd">        nHost : float</span>
<span class="sd">            the refractive index of the host</span>
<span class="sd">        nClad : float</span>
<span class="sd">            the refractive index of the cladding</span>
<span class="sd">        NA : float</span>
<span class="sd">            the numerical aperture of the fiber</span>

<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig, ax: the figure and axis objects</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">CenteredRectangle</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="k">return</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">BottomRectangle</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="k">return</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
    <span class="n">coreRadius</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;coreRadius&#39;</span><span class="p">]</span>
    <span class="n">mlRadius</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;mlRadius&#39;</span><span class="p">]</span>
    <span class="n">Δ</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;Δ&#39;</span><span class="p">]</span>
    <span class="n">mlPitch</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;mlPitch&#39;</span><span class="p">]</span>
    <span class="n">emDepth</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;emDepth&#39;</span><span class="p">]</span>
    <span class="n">emΔxy</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;emΔxy&#39;</span><span class="p">]</span>
    <span class="n">emΔz</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;emΔz&#39;</span><span class="p">]</span>
    <span class="n">mlHeight</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;mlHeight&#39;</span><span class="p">]</span>
    <span class="n">λFree</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;λFree&#39;</span><span class="p">]</span>
    <span class="n">nCore</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;nCore&#39;</span><span class="p">]</span>
    <span class="n">nHost</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;nHost&#39;</span><span class="p">]</span>
    <span class="n">wholeWidth</span>  <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">coreRadius</span><span class="p">,</span> <span class="n">mlRadius</span><span class="p">)</span>
    <span class="n">textframe</span>   <span class="o">=</span> <span class="n">wholeWidth</span> <span class="o">*</span> <span class="mf">0.05</span>
    <span class="n">fiberTip</span>    <span class="o">=</span> <span class="n">emDepth</span><span class="o">*</span> <span class="mf">0.75</span>
    <span class="n">NA</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;NA&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;nCladding&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">device_design</span><span class="p">:</span>
        <span class="n">nCladding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nCore</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">NA</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nCladding</span> <span class="o">=</span> <span class="n">device_design</span><span class="p">[</span><span class="s1">&#39;nCladding&#39;</span><span class="p">]</span>
    <span class="n">designSpec</span>  <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;λFree = </span><span class="si">{</span><span class="n">λFree</span><span class="o">*</span><span class="mi">1000</span><span class="si">}</span><span class="s1"> nm&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;Δ = </span><span class="si">{</span><span class="n">Δ</span><span class="si">}</span><span class="s1"> μm&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;coreRad = </span><span class="si">{</span><span class="n">coreRadius</span><span class="si">}</span><span class="s1"> μm&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;mlHeight = </span><span class="si">{</span><span class="n">mlHeight</span><span class="si">}</span><span class="s1"> μm&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;emDepth = </span><span class="si">{</span><span class="n">emDepth</span><span class="si">}</span><span class="s1"> μm&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;Δxy = </span><span class="si">{</span><span class="n">emΔxy</span><span class="si">}</span><span class="s1"> μm&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;nCore = </span><span class="si">{</span><span class="n">nCore</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;nHost = </span><span class="si">{</span><span class="n">nHost</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;nClad = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nCladding</span><span class="p">,</span>
                <span class="s1">&#39;fiberNA = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">NA</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;Δz = </span><span class="si">{</span><span class="n">emΔz</span><span class="si">}</span><span class="s1"> μm&#39;</span><span class="p">]</span>
    <span class="n">designSpec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">designSpec</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">designSpec</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">designSpec</span><span class="p">)</span>
    <span class="n">wholeHeight</span> <span class="o">=</span> <span class="p">(</span><span class="n">fiberTip</span> <span class="o">+</span> <span class="n">Δ</span> <span class="o">+</span> <span class="n">mlHeight</span> <span class="o">+</span> <span class="n">emDepth</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">emΔz</span><span class="p">)</span>
    <span class="n">top_left_corner</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">wholeWidth</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">textframe</span><span class="p">,</span> <span class="n">wholeHeight</span><span class="o">-</span><span class="n">fiberTip</span> <span class="o">-</span> <span class="n">textframe</span><span class="p">)</span>
    <span class="n">finalFieldWidth</span>  <span class="o">=</span>  <span class="mi">2</span><span class="o">*</span><span class="n">emΔxy</span><span class="o">*</span><span class="mi">1</span>
    <span class="n">finalFieldHeight</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">*</span><span class="n">emΔz</span><span class="o">*</span><span class="mi">1</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">clad</span> <span class="o">=</span> <span class="n">BottomRectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">-</span><span class="n">fiberTip</span><span class="p">),</span> <span class="n">wholeWidth</span><span class="p">,</span> <span class="n">fiberTip</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">clad</span><span class="p">)</span>
    <span class="n">core</span> <span class="o">=</span> <span class="n">BottomRectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">-</span><span class="n">fiberTip</span><span class="p">),</span> <span class="n">coreRadius</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">fiberTip</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
    <span class="n">ml</span> <span class="o">=</span> <span class="n">BottomRectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">fiberTip</span> <span class="o">+</span> <span class="n">Δ</span> <span class="o">-</span> <span class="n">fiberTip</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">mlRadius</span><span class="p">,</span> <span class="n">mlHeight</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
    <span class="n">host</span> <span class="o">=</span> <span class="n">BottomRectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">fiberTip</span> <span class="o">+</span> <span class="n">Δ</span> <span class="o">+</span> <span class="n">mlHeight</span> <span class="o">-</span> <span class="n">fiberTip</span><span class="p">),</span> <span class="n">wholeWidth</span><span class="p">,</span> <span class="n">wholeHeight</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
    <span class="n">fieldBox</span> <span class="o">=</span> <span class="n">CenteredRectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">fiberTip</span> <span class="o">+</span> <span class="n">Δ</span> <span class="o">+</span> <span class="n">mlHeight</span> <span class="o">+</span> <span class="n">emDepth</span> <span class="o">-</span> <span class="n">fiberTip</span><span class="p">),</span> <span class="n">finalFieldWidth</span><span class="p">,</span> <span class="n">finalFieldHeight</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">fieldBox</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">wholeWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">wholeWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">fiberTip</span><span class="p">,</span> <span class="n">wholeHeight</span> <span class="o">-</span> <span class="n">fiberTip</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="o">-</span> <span class="n">fiberTip</span><span class="p">,</span> <span class="n">wholeHeight</span><span class="o">-</span> <span class="n">fiberTip</span><span class="p">]),</span> <span class="s1">&#39;w:&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">*</span><span class="n">top_left_corner</span><span class="p">,</span> <span class="n">designSpec</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;family&#39;</span><span class="p">:</span> <span class="s1">&#39;monospace&#39;</span><span class="p">})</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x/μm&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;z/μm&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="simpson_weights_1D">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.simpson_weights_1D">[docs]</a>
<span class="k">def</span> <span class="nf">simpson_weights_1D</span><span class="p">(</span><span class="n">numSamples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    simpson_weights_1D  returns  the  weights  for Simpson&#39;s rule for 1D</span>
<span class="sd">    numerical integration. Ff there&#39;s an even number of intervals (which</span>
<span class="sd">    is  the  same  as  an odd number of samples) the 1/3 Simpson rule is</span>
<span class="sd">    used. If there&#39;s an odd number of intervals (which is the same as an</span>
<span class="sd">    even number of samples) then Simpson&#39;s 1/3 is used for the first n-3</span>
<span class="sd">    points and the 3/8 rule is used for the remaining tail.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numSamples : int</span>
<span class="sd">        how many evaluation points are avaiable for integration</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BSimpson : np.array</span>
<span class="sd">        array of weights for the mixed Simpson&#39;s rule.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">numSamples</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">BSimpson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">numSamples</span><span class="p">))</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">BSimpson</span> <span class="o">/=</span> <span class="mf">3.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">BSimpson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">numSamples</span><span class="p">))</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">BSimpson</span> <span class="o">/=</span> <span class="mf">3.</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">/</span><span class="mf">8.</span>
        <span class="n">BSimpson</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">::]</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">BSimpson</span></div>


<div class="viewcode-block" id="FFT2D_convolution_integral">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.FFT2D_convolution_integral">[docs]</a>
<span class="k">def</span> <span class="nf">FFT2D_convolution_integral</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">Usamples</span><span class="p">,</span> <span class="n">kernelFun</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    FFT2D_convolution_integral  takes  the  sampled values of a function</span>
<span class="sd">    U(x,y) on a square domain and computes the convolution integral with</span>
<span class="sd">    the  given kernel. The domain of integration is given by xCoords and</span>
<span class="sd">    yCoords,   where  it  is  assumed  that  the  elements  of  Usamples</span>
<span class="sd">    correspond       to       xCorrds,       yCoords      such      that</span>
<span class="sd">    :math:`\\text{Usamples}[i,j]         =         U(\\text{yCoords}[j],</span>
<span class="sd">    \\text{xCoords}[i])`.</span>

<span class="sd">    Usamples  is  numeric,  whereas  kernelFun  must  be  provided  as a</span>
<span class="sd">    bivariate function.</span>

<span class="sd">    The convolution has the same domain as the sample values for U.</span>

<span class="sd">    .. math:: I(x&#39;,y&#39;) = \iint_\mathcal{A} U(x,y) \mathcal{K}(x-x&#39;, y-y&#39;) dxdy</span>

<span class="sd">    This   is  done  by  interpreting  the  discretized  integral  as  a</span>
<span class="sd">    convolution,  so  that the convolution may be performed with help of</span>
<span class="sd">    the fast Fourier transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xCoords : np.array</span>
<span class="sd">        x-coordinates on the source plane indexed to the given Usamples.</span>

<span class="sd">    yCoords : np.array</span>
<span class="sd">        y-coordinates on the source plane indexed to the given Usamples.</span>

<span class="sd">    Usamples : np.array</span>
<span class="sd">        complex  amplitude  of  the  field  in the source plane,</span>
<span class="sd">        sampled according to the coordinates provided by xCoords</span>
<span class="sd">        and yCoords. Must be a square array.</span>

<span class="sd">    kernelFun : func</span>
<span class="sd">        a bivariate function of the cartesian x,y coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    integral : np.array</span>
<span class="sd">        resultant  convolution  integral. The top left corner of</span>
<span class="sd">        the  array  corresponds  to the lower left corner of the</span>
<span class="sd">        observation  plane. The coordinates associated with each</span>
<span class="sd">        element  in  the  given array correspond to the original</span>
<span class="sd">        xCoords, yCoords.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">numSamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xCoords</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xCoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">yCoords</span><span class="p">),</span> <span class="s2">&quot;Input must be square.&quot;</span>
    <span class="c1"># side of the integration domain</span>
    <span class="n">Lobs</span> <span class="o">=</span> <span class="p">(</span><span class="n">xCoords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Δζ</span> <span class="o">=</span> <span class="n">Lobs</span> <span class="o">/</span> <span class="p">(</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Δη</span> <span class="o">=</span> <span class="n">Δζ</span>

    <span class="c1"># Simpson&#39;s rule with 3/8 tail correction</span>
    <span class="n">BSimpson</span> <span class="o">=</span> <span class="n">simpson_weights_1D</span><span class="p">(</span><span class="n">numSamples</span><span class="p">)</span>
    <span class="n">BSimpson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">BSimpson</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">BSimpson</span><span class="p">)</span>

    <span class="n">xCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">Lobs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Lobs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">)</span>
    <span class="n">yCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">Lobs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Lobs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">numSamples</span><span class="p">)</span>
    
    <span class="n">padextra</span> <span class="o">=</span> <span class="p">(</span><span class="n">numSamples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Usamples</span> <span class="o">=</span> <span class="n">Usamples</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Usamples</span> <span class="o">=</span> <span class="n">BSimpson</span> <span class="o">*</span> <span class="n">Usamples</span>
    <span class="n">Usamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">Usamples</span><span class="p">,</span> 
            <span class="n">pad_width</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">padextra</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">padextra</span><span class="p">)),</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
            <span class="n">constant_values</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

    <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">xCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">ζ0</span><span class="p">,</span> <span class="n">η0</span> <span class="o">=</span> <span class="n">xCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Put together the H array</span>
    <span class="n">Hx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">x0</span><span class="p">)</span>
    <span class="n">Hx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Hx</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Hx1</span><span class="p">,</span> <span class="n">Hx2</span><span class="p">))</span>

    <span class="n">Hζ2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ζ0</span><span class="p">)</span>
    <span class="n">Hζ1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">xCoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Hζ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Hζ1</span><span class="p">,</span> <span class="n">Hζ2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">Hxζ</span> <span class="o">=</span> <span class="n">Hx</span> <span class="o">-</span> <span class="n">Hζ</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Hy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">y0</span><span class="p">)</span>
    <span class="n">Hy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">yCoords</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Hy</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Hy1</span><span class="p">,</span> <span class="n">Hy2</span><span class="p">))</span>

    <span class="n">Hη2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">η0</span><span class="p">)</span>
    <span class="n">Hη1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">yCoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numSamples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Hη</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Hη1</span><span class="p">,</span> <span class="n">Hη2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">Hyη</span> <span class="o">=</span> <span class="p">(</span><span class="n">Hy</span> <span class="o">-</span> <span class="n">Hη</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Evaluate the kernel</span>
    <span class="n">Hfield</span> <span class="o">=</span> <span class="n">kernelFun</span><span class="p">(</span><span class="n">Hxζ</span><span class="p">,</span> <span class="n">Hyη</span><span class="p">)</span>

    <span class="c1"># compute the Fourier transforms</span>
    <span class="n">FFU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">Usamples</span><span class="p">)</span>
    <span class="n">FFH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">Hfield</span><span class="p">)</span>

    <span class="c1"># perform the convolution</span>
    <span class="n">FFUH</span> <span class="o">=</span> <span class="n">FFU</span> <span class="o">*</span> <span class="n">FFH</span>

    <span class="c1"># invert the result</span>
    <span class="n">Sfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">FFUH</span><span class="p">)</span>

    <span class="c1"># get the good parts</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="p">(</span><span class="n">Δη</span><span class="o">*</span><span class="n">Δζ</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sfield</span><span class="p">[</span><span class="o">-</span><span class="n">numSamples</span><span class="p">::,</span><span class="o">-</span><span class="n">numSamples</span><span class="p">::]</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="n">integral</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">integral</span></div>


<div class="viewcode-block" id="electric_vectorial_diffraction">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.electric_vectorial_diffraction">[docs]</a>
<span class="k">def</span> <span class="nf">electric_vectorial_diffraction</span><span class="p">(</span><span class="n">zProp</span><span class="p">,</span> <span class="n">incidentEfield</span><span class="p">,</span> <span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">λfree</span><span class="p">,</span> <span class="n">nref</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given  samples  of  the  electric  field  of an electromagnetic wave</span>
<span class="sd">    incident  on  the  aperture  plane z=z0, this function estimates the</span>
<span class="sd">    electric  field at the observation plane z = z0+zProp.  This is done</span>
<span class="sd">    using   the  vectorial  Smythe-Kirchhoff  diffraction  integral.  It</span>
<span class="sd">    assumes  that  both  the  space  below  and above the plane z=z0 are</span>
<span class="sd">    filled  with  a homogeneous medium with refractive index nref. Since</span>
<span class="sd">    the  diffraction integral only requires the transverse components of</span>
<span class="sd">    the  electric field, the input can include or not the z-component of</span>
<span class="sd">    the field in the source plane.</span>

<span class="sd">    This  assumes  that  the  field  is incident from below the aperture</span>
<span class="sd">    plane.</span>

<span class="sd">    .. math:: </span>
<span class="sd">        \\begin{align}</span>
<span class="sd">            \\vec{E}(x,y) &amp;= \\frac{1}{2\\pi} \\nabla \\times \\iint_\\mathcal{A} </span>
<span class="sd">            \\frac{e^{i k R}}{R} \\left(\\hat{z} \\times \\vec{E}(x&#39;,y&#39;,z=z_0) \\right)</span>
<span class="sd">            \\,\\,\\text{dx}\\text{dy} \\\\</span>
<span class="sd">            \\vec{R} &amp;= \\vec{r} - \\vec{r}&#39;</span>
<span class="sd">        \\end{align}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zProp : float</span>
<span class="sd">        the propagation distance along the z-axis.</span>

<span class="sd">    incidentEfield : np.array</span>
<span class="sd">        either  (3,N,N)  or (2,N,N), the incident electric field</span>
<span class="sd">        on  the  aperture  plane. The values given in it so that</span>
<span class="sd">        the  first  index references the x, y, or z component of</span>
<span class="sd">        the  incident  field.  Also the values are assumed to be</span>
<span class="sd">        anchored    to    the    coordinate   system   so   that</span>
<span class="sd">        incidentEfield[k,i,j]  gives  the  k-th component of the</span>
<span class="sd">        electric field at position xCoords[j], yCoords[i].</span>

<span class="sd">    xCoords : np.array (N,)</span>
<span class="sd">        coordinate array for the x-axis.</span>

<span class="sd">    yCoords : np.array (N,)</span>
<span class="sd">        coordinate array for the x-axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diffractedEfield  : np.array (3,N,N)</span>
<span class="sd">        the  diffracted field at the observation plane.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">λfree</span> <span class="o">*</span> <span class="n">nref</span>
    <span class="c1"># get the necessary kernels</span>
    <span class="n">kernel_pairs</span> <span class="o">=</span> <span class="n">dk</span><span class="o">.</span><span class="n">electricKernels</span><span class="p">(</span><span class="n">zProp</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="c1"># create the array to hold the diffracted field</span>
    <span class="n">diffractedEfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,)</span><span class="o">+</span><span class="n">incidentEfield</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kernel_pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kernel_pairs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kernel_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;null&#39;</span><span class="p">):</span>
            <span class="n">kernel_Ex</span> <span class="o">=</span> <span class="n">kernel_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">FFT2D_convolution_integral</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">incidentEfield</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kernel_Ex</span><span class="p">)</span>
            <span class="n">diffractedEfield</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kernel_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;null&#39;</span><span class="p">):</span>
            <span class="n">kernel_Ey</span> <span class="o">=</span> <span class="n">kernel_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">FFT2D_convolution_integral</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">incidentEfield</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kernel_Ey</span><span class="p">)</span>
            <span class="n">diffractedEfield</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span>
    <span class="k">return</span> <span class="n">diffractedEfield</span></div>


<div class="viewcode-block" id="magnetic_vectorial_diffraction">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.magnetic_vectorial_diffraction">[docs]</a>
<span class="k">def</span> <span class="nf">magnetic_vectorial_diffraction</span><span class="p">(</span><span class="n">zProp</span><span class="p">,</span> <span class="n">incidentEfield</span><span class="p">,</span> <span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">λfree</span><span class="p">,</span> <span class="n">nref</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given  samples  of  the  electric  field  of an electromagnetic wave</span>
<span class="sd">    incident  on  the  aperture  plane z=z0, this function estimates the</span>
<span class="sd">    magnecic H-field at the observation plane z = z0+zProp. This is done</span>
<span class="sd">    using   the  vectorial  Smythe-Kirchhoff  diffraction  integral.  It</span>
<span class="sd">    assumes  that  both  the  space  below  and above the plane z=z0 are</span>
<span class="sd">    filled  with  a homogeneous medium with refractive index nref. Since</span>
<span class="sd">    the  diffraction integral only requires the transverse components of</span>
<span class="sd">    the  electric field, the input can include or not the z-component of</span>
<span class="sd">    the field in the source plane.</span>

<span class="sd">    This  assumes  that  the  field  is incident from below the aperture</span>
<span class="sd">    plane.</span>

<span class="sd">    .. math:: </span>
<span class="sd">        \\begin{align}</span>
<span class="sd">        \\vec{H}(x,y) &amp;= \\frac{1}{2\\pi i \\omega} \\nabla \\left(\\nabla \\times \\iint_\\mathcal{A} </span>
<span class="sd">        \\frac{e^{i k R}}{R} \\left(\\hat{z} \\times \\vec{E}(x&#39;,y&#39;,z=z_0) \\right)</span>
<span class="sd">        \\,\\,\\text{dx}\\text{dy} \\right) \\\\</span>
<span class="sd">        \\vec{R} &amp;= \\vec{r} - \\vec{r}&#39;</span>
<span class="sd">        \\end{align}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zProp : float</span>
<span class="sd">        the propagation distance along the z-axis.</span>

<span class="sd">    incidentEfield : np.array</span>
<span class="sd">        either  (3,N,N)  or (2,N,N), the incident electric field</span>
<span class="sd">        on  the  aperture  plane. The values given in it so that</span>
<span class="sd">        the  first  index references the x, y, or z component of</span>
<span class="sd">        the  incident  field.  Also the values are assumed to be</span>
<span class="sd">        anchored    to    the    coordinate   system   so   that</span>
<span class="sd">        incidentEfield[k,i,j]  gives  the  k-th component of the</span>
<span class="sd">        electric field at position xCoords[j], yCoords[i].</span>

<span class="sd">    xCoords : np.array</span>
<span class="sd">        (N,) coordinate array for the x-axis.</span>

<span class="sd">    yCoords : np.array (N,)</span>
<span class="sd">        coordinate array for the x-axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diffractedHfield : np.array (3,N,N)</span>
<span class="sd">        the  diffracted field at the observation plane.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">kFree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">λfree</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">kFree</span> <span class="o">*</span> <span class="n">nref</span>
    <span class="n">ω</span> <span class="o">=</span> <span class="n">kFree</span>
    <span class="c1"># get the necessary kernels</span>
    <span class="n">kernel_pairs</span> <span class="o">=</span>  <span class="n">dk</span><span class="o">.</span><span class="n">magneticKernels</span><span class="p">(</span><span class="n">zProp</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="c1"># create the array to hold the diffracted field</span>
    <span class="n">diffractedHfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,)</span><span class="o">+</span><span class="n">incidentEfield</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kernel_pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kernel_pairs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kernel_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;null&#39;</span><span class="p">):</span>
            <span class="n">kernel_Ex</span> <span class="o">=</span> <span class="n">kernel_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">FFT2D_convolution_integral</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">incidentEfield</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kernel_Ex</span><span class="p">)</span>
            <span class="n">diffractedHfield</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kernel_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;null&#39;</span><span class="p">):</span>
            <span class="n">kernel_Ey</span> <span class="o">=</span> <span class="n">kernel_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">FFT2D_convolution_integral</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">incidentEfield</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kernel_Ey</span><span class="p">)</span>
            <span class="n">diffractedHfield</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span>
    <span class="n">diffractedHfield</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="n">ω</span> <span class="o">*</span> <span class="n">diffractedHfield</span>
    <span class="k">return</span> <span class="n">diffractedHfield</span></div>


<div class="viewcode-block" id="scalar_diffraction">
<a class="viewcode-back" href="../usage/wavesight.html#wavesight.scalar_diffraction">[docs]</a>
<span class="k">def</span> <span class="nf">scalar_diffraction</span><span class="p">(</span><span class="n">zProp</span><span class="p">,</span> <span class="n">incidentField</span><span class="p">,</span> <span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">λfree</span><span class="p">,</span> <span class="n">nref</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given  samples  of  the  electric  field  of an electromagnetic wave</span>
<span class="sd">    incident  on  the  aperture  plane z=z0, this function estimates the</span>
<span class="sd">    electric  field  at the observation plane z = z0+zProp. This is done</span>
<span class="sd">    using  the  Rayleigh-Sommerfeld  diffraction integral. This assuming</span>
<span class="sd">    that  that  both the space below and above the plane z=z0 are filled</span>
<span class="sd">    with  a  homogeneous  medium  with  refractive index nref.</span>

<span class="sd">    .. math:: </span>

<span class="sd">        E(x&#39;,y&#39;) = \\frac{1}{2\\pi} \\iint_\\mathcal{A} \\frac{e^{ikR}}{R} \\frac{z}{R} \\frac{(ikR-1)}{R} E(x&#39;,y&#39;) \\text{dxdy}</span>

<span class="sd">    This  assumes  that  the  field  is incident from below the aperture</span>
<span class="sd">    plane.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zProp : float</span>
<span class="sd">        the propagation distance along the z-axis.</span>

<span class="sd">    incidentEfield : np.array (N,N)</span>
<span class="sd">        the incident field on the aperture plane. The values are</span>
<span class="sd">        assumed  to be anchored to the coordinate system so that</span>
<span class="sd">        incidentEfield[i,j]  gives  the  value  of  the field at</span>
<span class="sd">        position xCoords[j], yCoords[i].</span>

<span class="sd">    + xCoords : np.array (N,)</span>
<span class="sd">        coordinate array for the x-axis.</span>

<span class="sd">    + yCoords : np.array  (N,)</span>
<span class="sd">        coordinate array for the x-axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diffractedEfield : np.array</span>
<span class="sd">        (N,N)  the  diffracted field at the observation plane.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">λfree</span> <span class="o">*</span> <span class="n">nref</span>
    <span class="c1"># get the necessary kernel</span>
    <span class="n">kernel_pairs</span> <span class="o">=</span> <span class="n">dk</span><span class="o">.</span><span class="n">electricKernels</span><span class="p">(</span><span class="n">zProp</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># create the array to hold the diffracte field</span>
    <span class="n">diffractedEfield</span> <span class="o">=</span> <span class="n">FFT2D_convolution_integral</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span> <span class="n">yCoords</span><span class="p">,</span> <span class="n">incidentField</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diffractedEfield</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>